<!DOCTYPE html SYSTEM "about:legacy-compat">
<html manifest="pamflet.manifest">
      <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <title>TypeQuux — Covariant Heterogenous Lists</title>
        
        <link rel="stylesheet" href="css/blueprint/screen.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/blueprint/grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/blueprint/print.css" type="text/css" media="print"/> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href={ relativeBase + "css/blueprint/ie.css" } type="text/css" media="screen, projection"/>
        <![endif]-->
        <link rel="stylesheet" href="css/pamflet.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamflet-print.css" type="text/css" media="print"/>
        <link rel="stylesheet" href="css/pamflet-grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/color_scheme-redmond.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-github.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-monokai.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamfletheight_2em_2em.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="js/jquery.collapse.js"></script>
        <script type="text/javascript" src="js/pamflet.js"></script>
        <script type="text/javascript">
          Pamflet.page.language = 'en';
        </script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"/><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <link rel="stylesheet" href="css/style.css" type="text/css" media="screen, projection"/>
        
        
      </head>
      <body class="color_scheme-redmond">
        <a class="page prev nav" href="Singleton+Types+for+Literals.html">
            <span class="space">&nbsp;</span>
            <span class="flip arrow">❧</span>
          </a><a class="page next nav" href="Tuple+Ops.html">
            <span class="space">&nbsp;</span>
            <span class="arrow">❧</span>
          </a>
        <div class="container contentswrapper">
          <div class="span-16 prepend-1 append-1 contents">
            <h2 id="Covariant+Heterogenous+Lists">Covariant Heterogenous Lists<a href="#Covariant+Heterogenous+Lists" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>TypeQuux ships with a rich API for operating on heterogenous lists and subsumes operations typically associated with klists. Operations that would result in runtime errors (mostly) do not compile. All indexed operations (<code>apply</code>, <code>drop</code>, <code>take</code> etc) are 0-based and can be indexed from the left or the right.
</p><p>The type signatures for hlists can be quite long and are not terribly informative in the examples presented below. <code>/**/</code> represents an omitted (for clarity) type signature. 
</p><h4 id="Covariance">Covariance<a href="#Covariance" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import typequux._ // package
import typequux._

scala&gt; import Typequux._ // useful imports
import Typequux._

scala&gt; type LT = String :+: AnyVal :+: AnyRef :+: Traversable[_] :+: Option[Int] :+: HNil
defined type alias LT

scala&gt; type ST = String :+: Long :+: Set[Double] :+: List[Int] :+: None.type :+: HNil
defined type alias ST

scala&gt; implicitly[ST &lt;:&lt; LT] // compiles
res0: &lt;:&lt;[ST,LT] = &lt;function1&gt;

scala&gt; val a =  &quot;mmm&quot; :+: 42L :+: Set(3.14, 2.718) :+: List(1, 2, 3) :+: None :+: HNil
a: /**/ = mmm :+: 42 :+: Set(3.14, 2.718) :+: List(1, 2, 3) :+: None :+: HNil

scala&gt; val l: LT = a
l: LT = mmm :+: 42 :+: Set(3.14, 2.718) :+: List(1, 2, 3) :+: None :+: HNil

scala&gt; val s: ST = a
s: ST = mmm :+: 42 :+: Set(3.14, 2.718) :+: List(1, 2, 3) :+: None :+: HNil
</code></pre><h4 id="You+can+concatenate+them">You can concatenate them<a href="#You+can+concatenate+them" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val a = 3 :+: &quot;ai4&quot; :+: List('r', 'h') :+: HNil; val b = '3' :+: 2 :+: 'j' :+: &quot;sdfh&quot; :+: HNil
a: /**/ = 3 :+: ai4 :+: List(r, h) :+: HNil
b: /**/ = 3 :+: 2 :+: j :+: sdfh :+: HNil

scala&gt; val ab = a :++: b
ab: /**/ = 3 :+: ai4 :+: List(r, h) :+: 3 :+: 2 :+: j :+: sdfh :+: HNil
</code></pre><h4 id="You+can+reverse+them">You can reverse them<a href="#You+can+reverse+them" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val x = &quot;str&quot; :+: true :+: 1 :+: Some(3.14) :+: HNil
x: /**/ = str :+: true :+: 1 :+: Some(3.14) :+: HNil

scala&gt; val xr = x.reverse
xr: /**/ = Some(3.14) :+: 1 :+: true :+: str :+: HNil

scala&gt; val xrr = xr.reverse
xrr: /**/ = str :+: true :+: 1 :+: Some(3.14) :+: HNil

scala&gt; x == xrr
res26: Boolean = true
</code></pre><h4 id="They+support+value+level+length">They support value level length<a href="#They+support+value+level+length" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val hl1 = true :+: &quot;foo&quot; :+: 2 :+: Some(&quot;one is waiting for you&quot;) :+: HNil
hl1: /**/ = true :+: foo :+: 2 :+: Some(one is waiting for you) :+: HNil

scala&gt; hl1.length
res1: Long = 4

scala&gt; HNil.length
res2: Long = 0
</code></pre><h4 id="You+can+select+an+element+using+an+integer+index">You can select an element using an integer index<a href="#You+can+select+an+element+using+an+integer+index" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val p = 3 :+: true :+: &quot;asdf&quot; :+: false :+: 'k' :+: () :+: 13 :+: 9.3 :+: HNil
p: /**/ = 3 :+: true :+: asdf :+: false :+: k :+: () :+: 13 :+: 9.3 :+: HNil

scala&gt; p(0) // note that the type information is preserved
res3: Int = 3

scala&gt; p(4)
res4: Char = k

scala&gt; p.right(0)
res5: Double = 9.3

scala&gt; p.right(6)
res6: Boolean = true

scala&gt; p(100) // does not compile
</code></pre><h4 id="You+can+drop+elements.">You can drop elements.<a href="#You+can+drop+elements." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The arguments is the number of elements to drop.
</p><pre><code class="prettyprint lang-scala">scala&gt; p.drop(0)
res7: /**/ = 3 :+: true :+: asdf :+: false :+: k :+: () :+: 13 :+: 9.3 :+: HNil

scala&gt; p.drop(4)
res8: /**/ = k :+: () :+: 13 :+: 9.3 :+: HNil

scala&gt; p.dropRight(4)
res10: /**/ = 3 :+: true :+: asdf :+: false :+: HNil

scala&gt; p.dropRight(6)
res12: /**/ = 3 :+: true :+: HNil
</code></pre><h4 id="You+can+take+elements.">You can take elements.<a href="#You+can+take+elements." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The argument is the number of elements to take.
</p><pre><code class="prettyprint lang-scala">scala&gt; p.take(0)
res13: /**/ = HNil

scala&gt; p.take(4)
res14: /**/ = 3 :+: true :+: asdf :+: false :+: HNil

scala&gt; p.takeRight(4)
res15: /**/ = k :+: () :+: 13 :+: 9.3 :+: HNil

scala&gt; p.takeRight(8)
res16: /**/ = 3 :+: true :+: asdf :+: false :+: k :+: () :+: 13 :+: 9.3 :+: HNil
</code></pre><h4 id="You+can+update+individual+elements">You can update individual elements<a href="#You+can+update+individual+elements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val m = &quot;p&quot; :+: 3 :+: 't' :+: Some(&quot;is&quot;) :+: HNil
m: /**/ = p :+: 3 :+: t :+: Some(is) :+: HNil

scala&gt; m.updated(2, 110)
res20: /**/ = p :+: 3 :+: 110 :+: Some(is) :+: HNil

scala&gt; m.updated(0, 2.718)
res21: /**/ = 2.718 :+: 3 :+: t :+: Some(is) :+: HNil

scala&gt; m.updatedRight(0, List(&quot;dogs&quot;, &quot;cats&quot;))
res22: /**/ = p :+: 3 :+: t :+: List(dogs, cats) :+: HNil

scala&gt; m.updatedRight(2, None)
res24: /**/ = p :+: None :+: t :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+remove+an+element">You can remove an element<a href="#You+can+remove+an+element" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; m.remove(0)
res28: /**/ = 3 :+: t :+: Some(is) :+: HNil

scala&gt; m.remove(3)
res29: /**/ = p :+: 3 :+: t :+: HNil

scala&gt; m.removeRight(0)
res30: /**/ = p :+: 3 :+: t :+: HNil

scala&gt; m.removeRight(2)
res31: /**/ = p :+: t :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+map+an+element">You can map an element<a href="#You+can+map+an+element" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; m.indexMap(1, (i: Int) =&gt; i &lt;&lt; 2)
res34: /**/ = p :+: 12 :+: t :+: Some(is) :+: HNil

scala&gt; m.indexMapRight(1, (c: Char) =&gt; (c.toInt, c))
res35: /**/ = p :+: 3 :+: (116,t) :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+flatmap+an+element">You can flatmap an element<a href="#You+can+flatmap+an+element" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">m.indexFlatMap(2, (c: Char) =&gt; c.toInt :+: (c.toString + &quot;asty&quot; :+: HNil))
res38: /**/ = p :+: 3 :+: 116 :+: tasty :+: Some(is) :+: HNil

scala&gt; m.indexFlatMapRight(1, (c: Char) =&gt; Some(c.toString + &quot;ense&quot;) :+: &quot;Negotiations&quot; :+: 42 :+: HNil)
res39: /**/ = p :+: 3 :+: Some(tense) :+: Negotiations :+: 42 :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+insert+an+element.">You can insert an element.<a href="#You+can+insert+an+element." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The index is the position at which the inserted element will go. 
</p><pre><code class="prettyprint lang-scala">scala&gt; m.insert(0, 3.14159)
res41: /**/ = 3.14159 :+: p :+: 3 :+: t :+: Some(is) :+: HNil

scala&gt; m.insert(2, &quot;2.718&quot;)
res42: /**/ = p :+: 3 :+: 2.718 :+: t :+: Some(is) :+: HNil

scala&gt; m.insertRight(0, Some(6.62607))
res43: /**/ = p :+: 3 :+: t :+: Some(is) :+: Some(6.62607) :+: HNil

scala&gt; m.insertRight(1, None)
res44: /**/ = p :+: 3 :+: t :+: None :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+insert+a+hlist.">You can insert a hlist.<a href="#You+can+insert+a+hlist." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The index is the position at which the head of the inserted hlist will go. 
</p><pre><code class="prettyprint lang-scala">scala&gt; m.insertM(0, true :+: &quot;foo&quot; :+: HNil)
res45: /**/ = true :+: foo :+: p :+: 3 :+: t :+: Some(is) :+: HNil

scala&gt; m.insertM(2, true :+: &quot;foo&quot; :+: HNil)
res46: /**/ = p :+: 3 :+: true :+: foo :+: t :+: Some(is) :+: HNil

scala&gt; m.insertMRight(0, true :+: &quot;foo&quot; :+: HNil) // essentially concatenation
res47: /**/ = p :+: 3 :+: t :+: Some(is) :+: true :+: foo :+: HNil

scala&gt; m.insertMRight(2, true :+: &quot;foo&quot; :+: HNil) 
res48: /**/ = p :+: 3 :+: true :+: foo :+: t :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+split+at+an+index">You can split at an index<a href="#You+can+split+at+an+index" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val w = 3 :+: true :+: &quot;asdf&quot; :+: 'k' :+: () :+: 9.3 :+: HNil
w: /**/ = 3 :+: true :+: asdf :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.splitAt(0)
res50: /**/ = (HNil,3 :+: true :+: asdf :+: k :+: () :+: 9.3 :+: HNil)

scala&gt; w.splitAt(3)
res51: /**/ = (3 :+: true :+: asdf :+: HNil,k :+: () :+: 9.3 :+: HNil)

scala&gt; w.splitAtRight(2)
res53: /**/ = (3 :+: true :+: asdf :+: k :+: HNil,() :+: 9.3 :+: HNil)

scala&gt; w.splitAtRight(4)
res54: /**/ = (3 :+: true :+: HNil,asdf :+: k :+: () :+: 9.3 :+: HNil)
</code></pre><h4 id="You+can+index+an+hlist+with+a+type.">You can index an hlist with a type.<a href="#You+can+index+an+hlist+with+a+type." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Type-indexes support <code>at</code>, <code>take</code>, <code>drop</code>, <code>update</code>, <code>remove</code>, <code>map</code>, <code>flatmap</code>, <code>element insertion</code>, <code>hlist insertion</code> and <code>splitAt</code>
</p><pre><code class="prettyprint lang-scala">scala&gt; w.t[String].at
res55: String = asdf

scala&gt; w.t[String].before
res56: /**/ = 3 :+: true :+: HNil

scala&gt; w.t[String].after
res57: /**/ = k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[String].drop
res58: /**/ = asdf :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[String].take
res59: /**/ = 3 :+: true :+: HNil

scala&gt; w.t[String].updated(19)
res60: /**/ = 3 :+: true :+: 19 :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[Unit].remove
res61: /**/ = 3 :+: true :+: asdf :+: k :+: 9.3 :+: HNil

scala&gt; w.t[Char].map(_.isUpper)
res62: /**/ = 3 :+: true :+: asdf :+: false :+: () :+: 9.3 :+: HNil

scala&gt; w.t[String].flatMap(s =&gt; s(0) :+: s.substring(1) :+: HNil)
res63: /**/ = 3 :+: true :+: a :+: sdf :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[String].insert(Some(4.4))
res64: /**/ = 3 :+: true :+: Some(4.4) :+: asdf :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[String].insertM(Some(true) :+: None :+: HNil)
res65: /**/ = 3 :+: true :+: Some(true) :+: None :+: asdf :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[Char].splitAt
res66: /**/ = (3 :+: true :+: asdf :+: HNil,k :+: () :+: 9.3 :+: HNil)
</code></pre><p>When indexing by type, if  case multiple elements have the indexed type, the element furthest to the right is selected
</p><pre><code class="prettyprint lang-scala">scala&gt; val ti = 3.14159 :+: &quot;john&quot; :+: List(&quot;puppy, kitten&quot;) :+: Some(&quot;snow&quot;) :+: &quot;ramsay&quot; :+: (22L, 11.14) :+: HNil
ti: /**/ = 3.14159 :+: john :+: List(puppy, kitten) :+: Some(snow) :+: ramsay :+: (22,11.14) :+: HNil

scala&gt; ti.t[String].at
res68: String = ramsay
</code></pre><h4 id="You+can+zip+two+hlists+together.">You can zip two hlists together.<a href="#You+can+zip+two+hlists+together." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The length of the resulting list is the minimum of the length of the originals
</p><pre><code class="prettyprint lang-scala">scala&gt; val rz = 3 :+: &quot;ai4&quot; :+: List('r', 'H') :+: HNil; val sz = '3' :+: 2 :+: 'j' :+: &quot;sdfh&quot; :+: HNil
rz: /**/ = 3 :+: ai4 :+: List(r, H) :+: HNil
sz: /**/ = 3 :+: 2 :+: j :+: sdfh :+: HNil

scala&gt; rz zip sz
res69: /**/ = (3,3) :+: (ai4,2) :+: (List(r, H),j) :+: HNil

scala&gt; sz zip rz
res70: /**/ = (3,3) :+: (2,ai4) :+: (j,List(r, H)) :+: HNil

scala&gt; rz zip sz.tail
res71: /**/ = (3,2) :+: (ai4,j) :+: (List(r, H),sdfh) :+: HNil
</code></pre><h4 id="If+each+element+of+a+hlist+is+a+tuple2%2C+you+can+unzip+it">If each element of a hlist is a tuple2, you can unzip it<a href="#If+each+element+of+a+hlist+is+a+tuple2%2C+you+can+unzip+it" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val tpls = (1, true) :+: (Some(&quot;string&quot;), &quot;99 bottles of beer on the wall&quot;) :+: (&quot;oogachaka&quot;, 42L) :+: HNil
tpls: /**/ = (1,true) :+: (Some(string),99 bottles of beer on the wall) :+: (oogachaka,42) :+: HNil

scala&gt; tpls.unzip
res72: /**/ = (1 :+: Some(string) :+: oogachaka :+: HNil,true :+: 99 bottles of beer on the wall :+: 42 :+: HNil)
</code></pre><h4 id="You+can+apply+natural+transformations+on+hlists">You can apply natural transformations on hlists<a href="#You+can+apply+natural+transformations+on+hlists" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val list2Option: List ~&gt; Option = new (List ~&gt; Option) {override def apply[T](x: List[T]) = x.headOption}
list2Option: /**/ = /**/

scala&gt; val hl1 = List(1, 2, 3) :+: List[Boolean]() :+: List(&quot;oogachaka&quot;, &quot;ho gaya&quot;) :+: HNil
hl1: /**/ = List(1, 2, 3) :+: List() :+: List(oogachaka, ho gaya) :+: HNil

scala&gt; hl1 transform list2Option
res73: /**/ = Some(1) :+: None :+: Some(oogachaka) :+: HNil

scala&gt; HNil transform list2Option
res74: /**/ = HNil
</code></pre><h4 id="You+can+down+convert+an+hlist">You can down convert an hlist<a href="#You+can+down+convert+an+hlist" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val list2Down: Vector ~&gt; Id = new (Vector ~&gt; Id) {override def apply[T](x: Vector[T]) = x(0)}
list2Down: /**/ = /**/

scala&gt; val hl2 = Vector(1, 2, 1) :+: Vector(true) :+: HNil
hl2: /**/ = Vector(1, 2, 1) :+: Vector(true) :+: HNil

scala&gt; hl2 down list2Down
res75: /**/ = 1 :+: true :+: HNil

scala&gt; HNil down list2Down
res76: /**/ = HNil
</code></pre><h4 id="You+can+apply+an+hlist+of+functions+to+a+hlist+of+arguments.">You can apply an hlist of functions to a hlist of arguments.<a href="#You+can+apply+an+hlist+of+functions+to+a+hlist+of+arguments." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Or you could yoda-apply it for kicks.
</p><pre><code class="prettyprint lang-scala">scala&gt; val y1 = 9.75 :+: 'x' :+: HNil
y1: /**/ = 9.75 :+: x :+: HNil

scala&gt; val y2 = -2.125 :+: 'X' :+: HNil
y2: /**/ = -2.125 :+: X :+: HNil

scala&gt; val f = ((x: Double) =&gt; x + 5) :+: ((x: Char) =&gt; x.isUpper) :+: HNil
f: /**/ = &lt;function1&gt; :+: &lt;function1&gt; :+: HNil

scala&gt;  f fapply y1
res77: /**/ = 14.75 :+: false :+: HNil

scala&gt;  f fapply y2
res78: /**/ = 2.875 :+: true :+: HNil

scala&gt;  y1 yapply f // yoda-application: to the data, apply the function
res79: /**/ = 14.75 :+: false :+: HNil

scala&gt;  y2 yapply f
res80: /**/ = 2.875 :+: true :+: HNil
</code></pre><h4 id="You+can+perform+arbitrary+arity+zips+and+zipwiths+with+hlists">You can perform arbitrary arity zips and zipwiths with hlists<a href="#You+can+perform+arbitrary+arity+zips+and+zipwiths+with+hlists" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val sz1 = List(1, 2, 3) :+: List(true, false) :+: HNil
sz1: /**/ = List(1, 2, 3) :+: List(true, false) :+: HNil

scala&gt; val sz2 = Vector(1, 2, 3) :+: Vector(true, false) :+: Vector(&quot;alpha&quot;, &quot;beta&quot;, &quot;charlie&quot;, &quot;delta&quot;) :+: Vector(3.14, 2.718, 6.262) :+: HNil
sz2: /**/ = Vector(1, 2, 3) :+: Vector(true, false) :+: Vector(alpha, beta, charlie, delta) :+: Vector(3.14, 2.718, 6.262) :+: HNil

scala&gt; sz1.azipped
res81: /**/ = List(1 :+: true :+: HNil, 2 :+: false :+: HNil)

scala&gt; sz2.azipped
res82: /**/ = Vector(1 :+: true :+: alpha :+: 3.14 :+: HNil, 2 :+: false :+: beta :+: 2.718 :+: HNil)

scala&gt; sz1.zipwith { case i :+: b :+: _ =&gt; (b, i) } 
res83: List[(Boolean, Int)] = List((true,1), (false,2))

scala&gt; sz2.zipwith { case i :+: b :+: s :+: d :+: _ =&gt; ((i, s), (b, d))}
res84: scala.collection.immutable.Vector[((Int, String), (Boolean, Double))] = Vector(((1,alpha),(true,3.14)), ((2,beta),(false,2.718)))

scala&gt; val fibs: Stream[BigInt] = BigInt(0) #:: BigInt(1) #:: fibs.zip(fibs.tail).map { n =&gt; n._1 + n._2}
fibs: Stream[BigInt] = Stream(0, ?)

scala&gt; val nats: Stream[Int] = Stream.from(1)
nats: Stream[Int] = Stream(1, ?)

scala&gt; val pows: Stream[Long] = {def go(n: Int): Stream[Long] = (1L &lt;&lt; n) #:: go(n + 1); go(1) }
pows: Stream[Long] = Stream(2, ?)

scala&gt; val fz1 = fibs :+: nats :+: HNil
fz1: /**/ = Stream(0, ?) :+: Stream(1, ?) :+: HNil

scala&gt; val fz2 = fibs :+: nats :+: pows :+: HNil
fz2: /**/ = Stream(0, ?) :+: Stream(1, ?) :+: Stream(2, ?) :+: HNil

scala&gt; val fz3 = fibs :+: nats :+: Stream.empty[String] :+: HNil
fz3: /**/ = Stream(0, ?) :+: Stream(1, ?) :+: Stream() :+: HNil

scala&gt; fz1.azipped
res85: /**/ = Stream(0 :+: 1 :+: HNil, ?)

scala&gt; (res85 take 5).toList
res87: /**/ = List(0 :+: 1 :+: HNil, 1 :+: 2 :+: HNil, 1 :+: 3 :+: HNil, 2 :+: 4 :+: HNil, 3 :+: 5 :+: HNil)

scala&gt; fz2.azipped
res88: /**/ = Stream(0 :+: 1 :+: 2 :+: HNil, ?)

scala&gt; (res88 take 3).toVector
res89: /**/ = Vector(0 :+: 1 :+: 2 :+: HNil, 1 :+: 2 :+: 4 :+: HNil, 1 :+: 3 :+: 8 :+: HNil)

scala&gt; fz3.azipped
res90: /**/ = Stream()

scala&gt; fz1.zipwith { case b :+: i :+: _ =&gt; (i, b) }
res91: Stream[(Int, BigInt)] = Stream((1,0), ?)

scala&gt; (res91 take 3).toArray
res92: Array[(Int, BigInt)] = Array((1,0), (2,1), (3,1))

scala&gt; fz2.zipwith { case b :+: i :+: l :+: _ =&gt; (i, (b, l)) }
res93: Stream[(Int, (BigInt, Long))] = Stream((1,(0,2)), ?)

scala&gt; (res93 take 3).toList
res94: List[(Int, (BigInt, Long))] = List((1,(0,2)), (2,(1,4)), (3,(1,8)))

scala&gt; fz3.zipwith { case b :+: i :+: s :+: _ =&gt; (i, b, s) }
res95: Stream[(Int, BigInt, String)] = Stream()
</code></pre><h4 id="Common+View+Operations">Common View Operations<a href="#Common+View+Operations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Provided that there exists an implicit conversion to a common type for each element type of a hlist, you can use <code>foreach</code>, <code>count</code>, <code>exists</code>, <code>forall</code> and <code>foldleft</code> as you would with a standard library list.
</p><pre><code class="prettyprint lang-scala">scala&gt; import language.implicitConversions
import language.implicitConversions

scala&gt; :paste
// Entering paste mode (ctrl-D to finish)

trait Lengthable {
  def length: Int
}
object Lengthable {
  implicit def int2Lengthable(i: Int): Lengthable = new Lengthable {
    override def length = i
  }
  implicit def string2Lengthable(s: String): Lengthable = new Lengthable {
    override def length = s.length
  }
  implicit def seq2Lengthable[T](s: Seq[T]): Lengthable = new Lengthable {
    override def length = s.length
  }
  implicit def bool2Lengthable(b: Boolean): Lengthable = new Lengthable {
    override def length = if (b) 1 else 0
  }
  implicit def tuple2Lengthable[T, U](t: (T, U))(implicit ev0: T =&gt; Lengthable, ev1: U =&gt; Lengthable): Lengthable =
    new Lengthable {
      override def length = t._1.length * t._2.length
    }
}

// Exiting paste mode, now interpreting.

defined trait Lengthable
defined object Lengthable

scala&gt; val cvt = 3 :+: &quot;oogachaka&quot; :+: List(1, 2, 3) :+: Vector(&quot;cow&quot;, &quot;chicken&quot;) :+: false :+: (5, &quot;ho gaya&quot;) :+: HNil
cvt: /**/ = 3 :+: oogachaka :+: List(1, 2, 3) :+: Vector(cow, chicken) :+: false :+: (5,ho gaya) :+: HNil

scala&gt; var maxl = 0
maxl: Int = 0

scala&gt; cvt.foreach[Lengthable](l =&gt; maxl = math.max(maxl, l.length))

scala&gt; maxl
res98: Int = 35

scala&gt; cvt.exists[Lengthable](_.length &lt; 10)
res99: Boolean = true

scala&gt; cvt.forall[Lengthable](_.length &gt;= 0)
res100: Boolean = true

scala&gt; cvt.forall[Lengthable](_.length &gt; 0)
res101: Boolean = false

scala&gt; cvt.count[Lengthable](_.length &gt; 5)
res102: Int = 2

scala&gt; cvt.foldLeft[Int, Lengthable](0)(_ + _.length)
res103: Int = 52
</code></pre><h4 id="They+can+be+converted+to+regular+lists">They can be converted to regular lists<a href="#They+can+be+converted+to+regular+lists" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The element type of the list is the least upper bound of the element types of the HList
</p><pre><code class="prettyprint lang-scala">scala&gt; val hlc1 = 42 :+: 22L :+: 3.14159 :+: 'c' :+: 2.718f :+: HNil
hlc1: /**/ = 42 :+: 22 :+: 3.14159 :+: c :+: 2.718 :+: HNil

scala&gt; hlc1.toList
res105: List[AnyVal] = List(42, 22, 3.14159, c, 2.718)

scala&gt; val hlc2 = List(1, 2, 3) :+: List(true, false) :+: HNil 
hlc2: /**/ = List(1, 2, 3) :+: List(true, false) :+: HNil

scala&gt; hlc2.toList
res106: List[List[AnyVal]] = List(List(1, 2, 3), List(true, false))

scala&gt; val hlc3 = Some(&quot;foo&quot;) :+: Some(Set(1, 2,3)) :+: HNil
hlc3: /**/ = Some(foo) :+: Some(Set(1, 2, 3)) :+: HNil

scala&gt; hlc3.toList
res107: List[Some[Object]] = List(Some(foo), Some(Set(1, 2, 3)))

scala&gt; val hlc4 = Some(&quot;foo&quot;) :+: Some(Set(1, 2,3)) :+: None :+: HNil
hlc4: /**/ = Some(foo) :+: Some(Set(1, 2, 3)) :+: None :+: HNil

scala&gt; hlc4.toList
res109: List[Option[Object]] = List(Some(foo), Some(Set(1, 2, 3)), None)
</code></pre><h3 id="See+also">See also<a href="#See+also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/Records.html">Records</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Understanding+Constraints.html">Constraints</a>
</li></ul><div class="bottom nav span-16">
                        <em>Next Page</em>
                        <span class="arrow">❧</span>
                        <a href="Tuple+Ops.html"> Tuple Ops </a>                        
                        
                      </div><div class="tocwrapper show">
      <a class="tochead nav" style="display: none" href="#toc">❦</a>
      <a name="toc"></a>
      <h4 class="toctitle">Contents</h4>
      <div class="tocbody">
      <div><a href="TypeQuux.html">TypeQuux</a></div><ol class="toc"> <li><div><a href="Two+Quick+Examples.html">Two Quick Examples</a></div></li><li><div><a href="Pre+Requisites.html">Pre Requisites</a></div></li><li><div><a href="Usage.html">Usage</a></div><ol class="toc"> <li><div><a href="Church+Encoding+of+Booleans.html">Church Encoding of Booleans</a></div></li><li><div><a href="Peano+Numbers.html">Peano Numbers</a></div></li><li><div><a href="Dense+Numbers.html">Dense Numbers</a></div></li><li><div><a href="Type+Sets.html">Type Sets</a></div></li><li><div><a href="Type+Maps.html">Type Maps</a></div></li><li><div><a href="Natural+Transformations.html">Natural Transformations</a></div></li><li><div><a href="Type-Unions+and+Exclusions.html">Type-Unions and Exclusions</a></div></li><li><div><a href="Singleton+Types+for+Literals.html">Singleton Types for Literals</a></div></li><li><div class="current">Covariant Heterogenous Lists</div></li><li><div><a href="Tuple+Ops.html">Tuple Ops</a></div></li><li><div><a href="Sized+Vectors.html">Sized Vectors</a></div></li><li><div><a href="String+Indexed+Collections.html">String Indexed Collections</a></div></li><li><div><a href="Records.html">Records</a></div></li><li><div><a href="Understanding+Constraints.html">Understanding Constraints</a></div></li> </ol></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol></div></div>
          </div>
        </div>
        <div class="header">
          <div class="container">
        <div class="span-16 prepend-1 append-1">
          <div class="span-16 top nav">
            <div class="span-16 title">
              <span>TypeQuux</span> — Covariant Heterogenous Lists
            </div>
          </div>
        </div>
      </div>
        </div>
        <div class="footer">
          
        </div>
        <a href="http://github.com/harshad-deo/typequux" class="fork nav"><img src="img/fork.png" alt="Fork me on GitHub"/></a>
        
      </body>
    </html>