<!DOCTYPE html SYSTEM "about:legacy-compat">
<html>
      <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <title>TypeQuux — Combined Pages</title>
        
        <link rel="stylesheet" href="css/blueprint/screen.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/blueprint/grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/blueprint/print.css" type="text/css" media="print"/> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href={ relativeBase + "css/blueprint/ie.css" } type="text/css" media="screen, projection"/>
        <![endif]-->
        <link rel="stylesheet" href="css/pamflet.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamflet-print.css" type="text/css" media="print"/>
        <link rel="stylesheet" href="css/pamflet-grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/color_scheme-redmond.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-github.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-monokai.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamfletheight_2em_2em.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="js/jquery.collapse.js"></script>
        <script type="text/javascript" src="js/pamflet.js"></script>
        <script type="text/javascript">
          Pamflet.page.language = 'en';
        </script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"/><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <link rel="stylesheet" href="css/style.css" type="text/css" media="screen, projection"/>
        
        
      </head>
      <body class="color_scheme-redmond">
        <a class="page prev nav" href="Contents+in+Depth.html">
            <span class="space">&nbsp;</span>
            <span class="flip arrow">❧</span>
          </a>
        <div class="container contentswrapper">
          <div class="span-16 prepend-1 append-1 contents">
            <div class="tocwrapper show">
      <a class="tochead nav" style="display: none" href="#toc">❦</a>
      <a name="toc"></a>
      <h4 class="toctitle">Contents</h4>
      <div class="tocbody">
      <div><a href="#TypeQuux">TypeQuux</a></div><ol class="toc"> <li><div><a href="#Two+Quick+Examples">Two Quick Examples</a></div></li><li><div><a href="#Pre+Requisites">Pre Requisites</a></div></li><li><div><a href="#Usage">Usage</a></div><ol class="toc"> <li><div><a href="#Church+Encoding+of+Booleans">Church Encoding of Booleans</a></div></li><li><div><a href="#Peano+Numbers">Peano Numbers</a></div></li><li><div><a href="#Dense+Numbers">Dense Numbers</a></div></li><li><div><a href="#Type+Sets">Type Sets</a></div></li><li><div><a href="#Type+Maps">Type Maps</a></div></li><li><div><a href="#Natural+Transformations">Natural Transformations</a></div></li><li><div><a href="#Type-Unions+and+Exclusions">Type-Unions and Exclusions</a></div></li><li><div><a href="#Singleton+Types+for+Literals">Singleton Types for Literals</a></div></li><li><div><a href="#Covariant+Heterogenous+Lists">Covariant Heterogenous Lists</a></div></li><li><div><a href="#Tuple+Ops">Tuple Ops</a></div></li><li><div><a href="#Sized+Vectors">Sized Vectors</a></div></li><li><div><a href="#String+Indexed+Collections">String Indexed Collections</a></div></li><li><div><a href="#Records">Records</a></div></li><li><div><a href="#Understanding+Constraints">Understanding Constraints</a></div></li> </ol></li> </ol></div></div><h1 id="TypeQuux">TypeQuux<a href="#TypeQuux" class="header-link"><span class="header-link-content">&nbsp;</span></a></h1><p>Typelevel programming allows developers to encode several flavours of runtime invariants into the type system. 
Unfortunately, libraries that support typelevel programming tend to be poorly documented, difficult to understand and 
difficult to hack. 
</p><p>This makes them hard to customize to the needs of a specific project/problem. TypeQuux provides concise, 
efficient and easy-to-modify implementations of several typelevel programming primitives. As such, it represents 
collected wisdom on type-hackery in scala.
</p><p>You can now:
</p><ul><li>Head over to the <a href="https://github.com/harshad-deo/typequux">github page</a> which has instructions on how to set-up a project
</li><li>Peruse through the <a href="https://harshad-deo.github.io/typequux/api/#typequux.package">API</a>
</li><li>Read the examples below
</li></ul><p>Happy Hacking!
</p><h2 id="Two+Quick+Examples">Two Quick Examples<a href="#Two+Quick+Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Here are two quick examples to illustrate the look, feel and abilities of the API. 
</p><h2 id="Constraints+help+you+abstract+over+structure">Constraints help you abstract over structure<a href="#Constraints+help+you+abstract+over+structure" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><pre><code class="prettyprint lang-scala">scala&gt; import typequux._ // importing the package
import typequux._

scala&gt; import typequux._ // importing the package object
import typequux._

scala&gt; import constraint._ // importing the constraints API
import constraint._

scala&gt; def atExample[R](i: LiteralHash[_], r: R)(implicit ev: AtConstraint[i.ValueHash, R, String]): String = ev(r)
atExample: [R](i: typequux.LiteralHash[_], r: R)(implicit ev: typequux.constraint.AtConstraint[i.ValueHash,R,String])String
</code></pre><p>A <code>LiteralHash[T]</code> is an encapsulation of the singleton type associated with a literal of type <code>T</code>. The <code>ValueHash</code> is the 
singleton type associated with the value of the literal. The companion object for <code>LiteralHash</code> containt implicit converters
to build the objects from the regular literals. You can find out more <a href="https://harshad-deo.github.io/typequux/Singleton+Types+for+Literals.html">here</a>.
</p><p>Constraints are typeclasses that abstract over specific typelevel datastructures like <a href="https://harshad-deo.github.io/typequux/Covariant+Heterogenous+Lists.html">HLists</a>, <a href="https://harshad-deo.github.io/typequux/String+Indexed+Collections.html">StringIndexedCollections</a> and <a href="https://harshad-deo.github.io/typequux/Records.html">Records</a> (and also programming techniques like structural induction) to encode the invariants associated with the problem. 
They are called constraints because one or more of the type parameters can be fixed to encode a specific condition. 
You can find out more <a href="https://harshad-deo.github.io/typequux/Understanding+Constraints.html">here</a>. 
</p><p>In this example, the encoded invariant is that given an index (<code>ValueHash</code>) and an object of type <code>R</code>, the value at the index position should be a <code>String</code>. 
<strong>It should be stressed that this is achieved without using runtime reflection or structural types.</strong>
</p><p>This can be used with sequentially indexed collections, like HLists and Tuples (the regular scala tuples).
</p><pre><code class="prettyprint lang-scala">scala&gt; atExample(1, true :+: &quot;foo&quot; :+: 42L :+: HNil) // this is a HList
res1: String = foo

scala&gt; atExample(2, true :+: &quot;foo&quot; :+: 42L :+: HNil) // does not compile

scala&gt; atExample(2, &quot;oogachaka&quot; :+: 3.14159 :+: &quot;2.718&quot; :+: Some(&quot;one is spying on you&quot;) :+: HNil)
res3: String = 2.718

scala&gt; import TupleOps._ // pimp my tuples
import TupleOps._

scala&gt; atExample(1, (true, &quot;foo&quot;, 42L))
res4: String = foo

scala&gt; atExample(2, (3.14159, Some(&quot;one is spying on you&quot;), &quot;oogachaka&quot;, 42L, List(1, 2,3)))
res6: String = oogachaka
</code></pre><p>The same code can also be used with string indexed collections, like <code>StringIndexedCollections</code> (in which all elements are of the same type)
or <code>Records</code> (in which they can be of different types). The type signatures for these can be quite complicated and dont communicate much. 
For clarity, they are replaced below with <code>\**\</code>. 
</p><pre><code class="prettyprint lang-scala">scala&gt; val si1 = SINil.add(&quot;name&quot;, &quot;goku&quot;).add(&quot;son&quot;, &quot;gohan&quot;).add(&quot;friend&quot;, &quot;krillin&quot;) // String Indexed Collection
si1: /**/

scala&gt; val si2 = SINil.add(&quot;leader&quot;, &quot;Frieza&quot;).add(&quot;henchmen&quot;, &quot;ginyu&quot;).add(&quot;father&quot;, &quot;king cold&quot;)
si2: /**/

scala&gt; atExample(&quot;name&quot;, si1)
res7: String = goku

scala&gt; atExample(&quot;name&quot;, si2) // does not compile

scala&gt; val si3 = SINil.add(&quot;house&quot;, &quot;Lannister&quot;).add(&quot;name&quot;, &quot;Tyrion&quot;).add(&quot;aka&quot;, &quot;The Imp&quot;)
si3: /**/

scala&gt; atExample(&quot;name&quot;, si3)
res10: String = Tyrion

scala&gt; val r1 = RNil.add(&quot;name&quot;, &quot;goku&quot;).add(&quot;powerlevel&quot;, 9000).add(&quot;friends&quot;, List(&quot;krillin&quot;, &quot;yamcha&quot;)) // Record
r1: /**/

scala&gt; val r2 = RNil.add(&quot;show&quot;, &quot;futurama&quot;).add(&quot;coolest&quot;, &quot;Zoidberg&quot;)
r2: /**/

scala&gt; atExample(&quot;name&quot;, r1)
res11: String = goku

scala&gt; atExample(&quot;name&quot;, r2) // does not compile

</code></pre><p>Or even classes
</p><pre><code class="prettyprint lang-scala">scala&gt; case class User(name: String, age: Int)
defined class User

scala&gt; atExample(&quot;name&quot;, Record.class2Record(User(&quot;Harshad&quot;, 24)))
res15: String = Harshad
</code></pre><h2 id="Arbitrary+Arity+Zips">Arbitrary Arity Zips<a href="#Arbitrary+Arity+Zips" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Less sexy but as useful as the above example is the ability to perform arbitrary arity zips. Here are a few quick examples:
</p><pre><code class="prettyprint lang-scala">scala&gt; (List(1, 2,3 ), List(1.1, 2.2, 4.4), List(true, false, false, true, true), List(&quot;philip&quot;, &quot;fry&quot;, &quot;bender&quot;, &quot;leela&quot;)).azipped // tuples
res16: List[(Int, Double, Boolean, String)] = List((1,1.1,true,philip), (2,2.2,false,fry), (3,4.4,false,bender))

scala&gt; (List(1, 2,3 ) :+: List(1.1, 2.2, 4.4) :+: List(true, false, false, true, true) :+: List(&quot;philip&quot;, &quot;fry&quot;, &quot;bender&quot;, &quot;leela&quot;) :+: HNil).azipped // HLists
res17: /**/ = List(1 :+: 1.1 :+: true :+: philip :+: HNil, 2 :+: 2.2 :+: false :+: fry :+: HNil, 3 :+: 4.4 :+: false :+: bender :+: HNil)

scala&gt; (Stream.from(1), Stream.continually(util.Random.nextBoolean)).zipwith((a: (Int, Boolean)) =&gt; if(a._2) a._1 * 100.0 else a._1 / 100.0)
res19: Stream[Double] = Stream(100.0, ?)

scala&gt; (res19 take 5).toVector
res20: Vector[Double] = Vector(100.0, 200.0, 0.03, 400.0, 0.05)
</code></pre><p>The rest of the project documentation provides details on these and other primitives. 
</p><h2 id="Pre+Requisites">Pre Requisites<a href="#Pre+Requisites" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>While scala is an advanced programming language and typelevel programming is an advanced aspect of scala, the library 
has been designed so as to be usable and modifiable without going into the gory-depths of the type system. 
</p><ul><li>The operations on hlists, tuples, sized vectors, string indexed collections and records are fairly straightforward and 
should be usable with a cursory knowledge of the type system.
</li><li>To use and compose the constraints API and type unions and exclusions, you should be familiar with the typeclass pattern. <a href="http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html">This</a> is a quick refresher.
</li><li>Singleton types for literals are implemented as dependent types, so you should be comfortable with dependent types to 
use them. You should be comfortable with macros if you want to fiddle with the implementation.
</li><li>The constraints API is implemented using indexers, transformers and zippers, which are implemented using structural induction. <a href="https://www.cs.cmu.edu/~rwh/introsml/techniques/structur.htm">Here</a> is a link to get you started.
</li><li>You should be comfortable with higher-kinds/type-constructors to use typelevel booleans, peano numbers, dense numbers, type-sets, type-maps and natural transformations. </li></ul><h2 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This section provides examples on the usage of the public APIs of the supplied primitives</p><h2 id="Church+Encoding+of+Booleans">Church Encoding of Booleans<a href="#Church+Encoding+of+Booleans" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Church booleans are the simplest typelevel constructs and are mostly used to establish invariants of more complex constructs. 
Functionally, they are an alias for a single type constructor that chooses from one of two alternatives. 
</p><pre><code class="prettyprint lang-scala">sealed trait Bool {
  type If [T &lt;: Up, F &lt;: Up, Up] &lt;: Up
}
trait True extends Bool {
  override type If[T &lt;: Up, F &lt;: Up, Up] = T
}
trait False extends Bool {
  override type If[T &lt;: Up, F &lt;: Up, Up] = F
}
</code></pre><p>The usage is pretty straightforward 
</p><pre><code class="prettyprint lang-scala">scala&gt; import typequux._ // package
import typequux._

scala&gt; import typequux._ // package object
import typequux._

scala&gt; type Rep[B &lt;: Bool] = B#If[Int, String, Any]
defined type alias Rep

scala&gt; implicitly[Rep[True] =:= Int]
res0: =:=[Rep[typequux.typequux.True],Int] = &lt;function1&gt;

scala&gt; implicitly[Rep[False] =:= String]
res1: =:=[Rep[typequux.typequux.False],String] = &lt;function1&gt;
</code></pre><p>The companion object implements type constructors for common operations. Supported operations are:
</p><h4 id="Conjunction">Conjunction<a href="#Conjunction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import Bool._
import Bool._

scala&gt; implicitly[False &amp;&amp; False =:= False]
res2: =:=[typequux.Bool.&amp;&amp;[typequux.typequux.False,typequux.typequux.False],typequux.typequux.False] = &lt;function1&gt;

scala&gt; implicitly[False &amp;&amp; True =:= False]
res3: =:=[typequux.Bool.&amp;&amp;[typequux.typequux.False,typequux.typequux.True],typequux.typequux.False] = &lt;function1&gt;

scala&gt; implicitly[True &amp;&amp; False =:= False]
res4: =:=[typequux.Bool.&amp;&amp;[typequux.typequux.True,typequux.typequux.False],typequux.typequux.False] = &lt;function1&gt;

scala&gt; implicitly[True &amp;&amp; True =:= True]
res5: =:=[typequux.Bool.&amp;&amp;[typequux.typequux.True,typequux.typequux.True],typequux.typequux.True] = &lt;function1&gt;
</code></pre><h4 id="Disjunction">Disjunction<a href="#Disjunction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[False || False =:= False]
res6: =:=[typequux.Bool.||[typequux.typequux.False,typequux.typequux.False],typequux.typequux.False] = &lt;function1&gt;

scala&gt; implicitly[True || False =:= True]
res7: =:=[typequux.Bool.||[typequux.typequux.True,typequux.typequux.False],typequux.typequux.True] = &lt;function1&gt;

scala&gt; implicitly[False || True =:= True]
res8: =:=[typequux.Bool.||[typequux.typequux.False,typequux.typequux.True],typequux.typequux.True] = &lt;function1&gt;

scala&gt; implicitly[True || True =:= True]
res9: =:=[typequux.Bool.||[typequux.typequux.True,typequux.typequux.True],typequux.typequux.True] = &lt;function1&gt;
</code></pre><h4 id="Negation">Negation<a href="#Negation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[Not[True] =:= False]
res10: =:=[typequux.Bool.Not[typequux.typequux.True],typequux.typequux.False] = &lt;function1&gt;

scala&gt; implicitly[Not[False] =:= True]
res11: =:=[typequux.Bool.Not[typequux.typequux.False],typequux.typequux.True] = &lt;function1&gt;

scala&gt; implicitly[Not[Not[True]] =:= True]
res12: =:=[typequux.Bool.Not[typequux.Bool.Not[typequux.typequux.True]],typequux.typequux.True] = &lt;function1&gt;
</code></pre><h4 id="Exclusive+Or">Exclusive Or<a href="#Exclusive+Or" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[False Xor False =:= False]
res13: =:=[typequux.Bool.Xor[typequux.typequux.False,typequux.typequux.False],typequux.typequux.False] = &lt;function1&gt;

scala&gt; implicitly[True Xor False =:= True]
res14: =:=[typequux.Bool.Xor[typequux.typequux.True,typequux.typequux.False],typequux.typequux.True] = &lt;function1&gt;

scala&gt; implicitly[False Xor True =:= True]
res15: =:=[typequux.Bool.Xor[typequux.typequux.False,typequux.typequux.True],typequux.typequux.True] = &lt;function1&gt;

scala&gt; implicitly[True Xor True =:= False]
res16: =:=[typequux.Bool.Xor[typequux.typequux.True,typequux.typequux.True],typequux.typequux.False] = &lt;function1&gt;
</code></pre><h4 id="Material+Implication">Material Implication<a href="#Material+Implication" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt;  implicitly[True -&gt;&gt; True =:= True]
res17: =:=[typequux.Bool.-&gt;&gt;[typequux.typequux.True,typequux.typequux.True],typequux.typequux.True] = &lt;function1&gt;

scala&gt; implicitly[True -&gt;&gt; False =:= False]
res18: =:=[typequux.Bool.-&gt;&gt;[typequux.typequux.True,typequux.typequux.False],typequux.typequux.False] = &lt;function1&gt;

scala&gt; implicitly[False -&gt;&gt; True =:= True]
res19: =:=[typequux.Bool.-&gt;&gt;[typequux.typequux.False,typequux.typequux.True],typequux.typequux.True] = &lt;function1&gt;

scala&gt; implicitly[False -&gt;&gt; False =:= True]
res20: =:=[typequux.Bool.-&gt;&gt;[typequux.typequux.False,typequux.typequux.False],typequux.typequux.True] = &lt;function1&gt;
</code></pre><h4 id="Equivalence">Equivalence<a href="#Equivalence" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[False Eqv False =:= True]
res21: =:=[typequux.Bool.Eqv[typequux.typequux.False,typequux.typequux.False],typequux.typequux.True] = &lt;function1&gt;

scala&gt; implicitly[False Eqv True =:= False]
res22: =:=[typequux.Bool.Eqv[typequux.typequux.False,typequux.typequux.True],typequux.typequux.False] = &lt;function1&gt;

scala&gt; implicitly[True Eqv False =:= False]
res23: =:=[typequux.Bool.Eqv[typequux.typequux.True,typequux.typequux.False],typequux.typequux.False] = &lt;function1&gt;

scala&gt; implicitly[True Eqv True =:= True]
res24: =:=[typequux.Bool.Eqv[typequux.typequux.True,typequux.typequux.True],typequux.typequux.True] = &lt;function1&gt;
</code></pre><p>These type constructors can be used to prove properties about other constructs. For example, total order transitivity of <a href="https://harshad-deo.github.io/typequux/Dense+Numbers.html">dense numbers</a>:
</p><pre><code class="prettyprint lang-scala">scala&gt; class TotalOrderTransitivity[A, B, C]
defined class TotalOrderTransitivity


scala&gt; import Dense._
import Dense._

scala&gt; :paste
// Entering paste mode (ctrl-D to finish)

implicit def toToTr[A &lt;: Dense, B &lt;: Dense, C &lt;: Dense](
      implicit ev: =:=[True, &amp;&amp;[A &lt;= B, B &lt;= C] -&gt;&gt; &lt;=[A, C]]): TotalOrderTransitivity[A, B, C] =
    new TotalOrderTransitivity[A, B, C]


// Exiting paste mode, now interpreting.

toToTr: [A &lt;: typequux.Dense, B &lt;: typequux.Dense, C &lt;: typequux.Dense](implicit ev: =:=[typequux.typequux.True,typequux.Bool.-&gt;&gt;[typequux.Bool.&amp;&amp;[typequux.Dense.&lt;=[A,B],typequux.Dense.&lt;=[B,C]],typequux.Dense.&lt;=[A,C]]])TotalOrderTransitivity[A,B,C]

scala&gt; implicitly[TotalOrderTransitivity[_3, _0, _12]]
res25: TotalOrderTransitivity[typequux.Dense._3,typequux.Dense._0,typequux.Dense._12] = TotalOrderTransitivity@386d4a02

scala&gt; implicitly[TotalOrderTransitivity[_3, _0, _2]]
res26: TotalOrderTransitivity[typequux.Dense._3,typequux.Dense._0,typequux.Dense._2] = TotalOrderTransitivity@4bfb88ce
</code></pre><h4 id="Value+Conversion">Value Conversion<a href="#Value+Conversion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; Bool.toBoolean[True]
res27: Boolean = true

scala&gt; Bool.toBoolean[False]
res28: Boolean = false
</code></pre><p>Church booleans can be shown to satisfy the following laws:
</p><ol><li>Associativity of Or: <code>||[A, B || C] =:= ||[A || B, C]</code>
</li><li>Associativity of And: <code>&amp;&amp;[A, B &amp;&amp; C] =:= &amp;&amp;[A &amp;&amp; B, C]</code>
</li><li>Commutativity of Or: <code>||[A, B] =:= ||[B, A]</code>
</li><li>Commutativity of And: <code>&amp;&amp;[A, B] =:= &amp;&amp;[B, A]</code>
</li><li>Distributivity of Or over And: <code>||[A, B &amp;&amp; C] =:= &amp;&amp;[A || B, A || C]</code>
</li><li>Distributivity of And over Or: <code>&amp;&amp;[A, B || C] =:= ||[A &amp;&amp; B, A &amp;&amp; C]</code>
</li><li>Identity for Or: <code>||[A, False] =:= A</code>
</li><li>Identity for And: <code>&amp;&amp;[A, True] =:= A</code>
</li><li>Annhilator for Or: <code>||[A, True] =:= True</code>
</li><li>Annhilator for And: <code>&amp;&amp;[A, False] =:= False</code>
</li><li>Idempotence of Or: <code>||[A, A] =:= A</code>
</li><li>Idempotence of And: <code>&amp;&amp;[A, A] =:= A</code>
</li><li>Absorption 1: <code>&amp;&amp;[A, A || B] =:= A</code>
</li><li>Absorbtion 2: <code>||[A, A &amp;&amp; B] =:= A</code>
</li><li>Complementation 1: <code>&amp;&amp;[A, Not[A]] =:= False</code>
</li><li>Complementation 2: <code>||[A, Not[A]] =:= True</code>
</li><li>Double Negation: <code>Not[Not[A]] =:= A</code>
</li><li>De Morgan 1: <code>&amp;&amp;[Not[A], Not[B]] =:= Not[A || B]</code>
</li><li>De Morgan 2: <code>||[Not[A], Not[B]] =:= Not[A &amp;&amp; B]</code>
</li></ol><p>Refer to the <a href="https://github.com/harshad-deo/typequux/blob/master/src/test/scala/typequux/BoolSpec.scala">test cases</a> for the proofs. 
</p><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.Bool">API</a>
</li><li><a href="https://github.com/harshad-deo/typequux/blob/master/src/main/scala/typequux/Bool.scala">Source</a></li></ul><h2 id="Peano+Numbers">Peano Numbers<a href="#Peano+Numbers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Many typelevel constructs like <a href="https://harshad-deo.github.io/typequux/Covariant+Heterogenous+Lists.html">heterogenous lists</a> (an in the case of this library, also <a href="https://harshad-deo.github.io/typequux/Type+Sets.html">type sets</a>, <a href="https://harshad-deo.github.io/typequux/Type+Maps.html">type maps</a>, <a href="https://harshad-deo.github.io/typequux/Singleton+Types+for+Literals.html">literal singleton types</a> and other constructs derived from them) rely on an encoding of natural numbers at the type level. Peano numbers are the simplest encodings of natural numbers - a numeric type is either 0 or a successor of another. 
</p><pre><code class="prettyprint lang-scala">sealed trait Nat 
trait Nat0 extends Nat
trait Succ[N &lt;: Nat] extends Nat

object Nat {
  type _0 = Nat0
  type _1 = Succ[_0]
  type _2 = Succ[_1]
  type _3 = Succ[_2]
  type _4 = Succ[_3]
  type _5 = Succ[_4]
  type _6 = Succ[_5]
  type _7 = Succ[_6]
  type _8 = Succ[_7]
  type _9 = Succ[_8]
}
</code></pre><p>Finding the successor or the predecessor is a constant time operation for peano numbers which is why they are often used as indexers. However, they are cumbersome to construct (since every preceding number needs to be constructed first) and every other operation requires linear time or worse. This makes them unsuitable for most of the more complex constructs included in the library, which is why typequux exclusively uses <a href="https://harshad-deo.github.io/typequux/Dense+Numbers.html">dense numbers</a>. A rich implementation of Peano numbers is provided nonetheless because it is an important primitive that may find utility in the code that you write. 
</p><p>The type constructers that are a part of the <code>Nat</code> trait are unlikely to be useful in practice. The companion object provided type constructors that implement common operations. Supported operations are:
</p><h4 id="Addition">Addition<a href="#Addition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import typequux._; import Nat._
import typequux._
import Nat._

scala&gt; implicitly[_2 + _3 =:= _5]
res0: =:=[typequux.Nat.+[typequux.Nat._2,typequux.Nat._3],typequux.Nat._5] = &lt;function1&gt;

scala&gt; implicitly[_4 + _0 =:= _4]
res1: =:=[typequux.Nat.+[typequux.Nat._4,typequux.Nat._0],typequux.Nat._4] = &lt;function1&gt;
</code></pre><h4 id="Multiplication">Multiplication<a href="#Multiplication" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[_5 * _0 =:= _0]
res2: =:=[typequux.Nat.*[typequux.Nat._5,typequux.Nat._0],typequux.Nat._0] = &lt;function1&gt;

scala&gt; implicitly[_1 * _6 =:= _6]
res3: =:=[typequux.Nat.*[typequux.Nat._1,typequux.Nat._6],typequux.Nat._6] = &lt;function1&gt;

scala&gt; implicitly[_2 * _3 =:= _6]
res4: =:=[typequux.Nat.*[typequux.Nat._2,typequux.Nat._3],typequux.Nat._6] = &lt;function1&gt;
</code></pre><h4 id="Exponentiation">Exponentiation<a href="#Exponentiation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[_6 ^ _0 =:= _1]
res5: =:=[typequux.Nat.^[typequux.Nat._6,typequux.Nat._0],typequux.Nat._1] = &lt;function1&gt;

scala&gt; implicitly[_7 ^ _1 =:= _7]
res6: =:=[typequux.Nat.^[typequux.Nat._7,typequux.Nat._1],typequux.Nat._7] = &lt;function1&gt;

scala&gt; implicitly[_1 ^ _4 =:= _1]
res8: =:=[typequux.Nat.^[typequux.Nat._1,typequux.Nat._4],typequux.Nat._1] = &lt;function1&gt;

scala&gt; implicitly[_2 ^ _3 =:= _8]
res10: =:=[typequux.Nat.^[typequux.Nat._2,typequux.Nat._3],typequux.Nat._8] = &lt;function1&gt;

scala&gt; implicitly[_3 ^ _2 =:= _9]
res11: =:=[typequux.Nat.^[typequux.Nat._3,typequux.Nat._2],typequux.Nat._9] = &lt;function1&gt;
</code></pre><h4 id="Factorial">Factorial<a href="#Factorial" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[Fact[_0] =:= _1]
res12: =:=[typequux.Nat.Fact[typequux.Nat._0],typequux.Nat._1] = &lt;function1&gt;

scala&gt; implicitly[Fact[_1] =:= _1]
res13: =:=[typequux.Nat.Fact[typequux.Nat._1],typequux.Nat._1] = &lt;function1&gt;

scala&gt; implicitly[Fact[_3] =:= _6]
res14: =:=[typequux.Nat.Fact[typequux.Nat._3],typequux.Nat._6] = &lt;function1&gt;
</code></pre><h4 id="Comparators">Comparators<a href="#Comparators" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import typequux._ // package object, for True, False
import typequux._

scala&gt; implicitly[_0 &lt; _3 =:= True]
res15: =:=[typequux.Nat.&lt;[typequux.Nat._0,typequux.Nat._3],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[_5 &lt;= _5 =:= True]
res16: =:=[typequux.Nat.&lt;=[typequux.Nat._5,typequux.Nat._5],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[_5 === _5 =:= True]
res17: =:=[typequux.Nat.===[typequux.Nat._5,typequux.Nat._5],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[_6 &gt;= _4 =:= True]
res18: =:=[typequux.Nat.&gt;=[typequux.Nat._6,typequux.Nat._4],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[_6 &gt; _4 =:= True]
res19: =:=[typequux.Nat.&gt;[typequux.Nat._6,typequux.Nat._4],typequux.True] = &lt;function1&gt;
</code></pre><h4 id="Subtraction">Subtraction<a href="#Subtraction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>It is implemented by a marker typeclass. The names of the anonymous classes generated are not particularly 
interesting and confuse the templating engine for the website. Thereofore, they are replaced below by <code>\**\</code>
</p><pre><code class="prettyprint lang-scala">scala&gt; implicitly[NatDiff[_0, _0, _0]]
res22: typequux.NatDiff[typequux.Nat._0,typequux.Nat._0,typequux.Nat._0] = \**\

scala&gt; implicitly[NatDiff[_3, _0, _3]]
res24: typequux.NatDiff[typequux.Nat._3,typequux.Nat._0,typequux.Nat._3] = \**\

scala&gt; implicitly[NatDiff[_6, _2, _4]]
res25: typequux.NatDiff[typequux.Nat._6,typequux.Nat._2,typequux.Nat._4] = \**\
</code></pre><h4 id="Value+Conversion">Value Conversion<a href="#Value+Conversion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; Nat.toInt[_0]
res26: Int = 0

scala&gt; Nat.toInt[_4]
res27: Int = 4

scala&gt; Nat.toInt[_5 + _9]
res28: Int = 14

scala&gt; Nat.toInt[_5 * _9]
res29: Int = 45
</code></pre><p>Peano numbers can be shown to satisfy:
</p><ol><li>Additive Commutativity: <code>+[A, B] =:= +[B, A]</code>
</li><li>Multiplicative Commutativity: <code>*[A, B] =:= *[B, A]</code>
</li><li>Additive Associativity: <code>+[A, +[B, C]] =:= +[+[A, B], C]</code>
</li><li>Multiplicative Associativity: <code>*[A, *[B, C]] =:= *[*[A, B], C]</code>
</li><li>Distributivity: <code>+[A * C, B * C] =:= *[A + B, C]</code>
</li><li>Additive Identity: <code>+[A, _0] =:= A, +[_0, A] =:= A</code>
</li><li>Multiplicative Identity: <code>*[A, _1] =:= A, *[_1, A] =:= A</code>
</li><li>Exponent Zero: <code>^[A, _0] =:= _1</code>
</li><li>Exponent Identity: <code>^[A, _1] =:= A</code>
</li><li>Exponent One: <code>^[_1, A] =:= _1</code>
</li><li>Total Order
</li></ol><p>Refer to the <a href="https://github.com/harshad-deo/typequux/blob/master/src/test/scala/typequux/NatSpec.scala">test cases</a> for examples. 
</p><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.Nat">API</a>
</li><li><a href="https://github.com/harshad-deo/typequux/blob/master/src/main/scala/typequux/Nat.scala">Source</a></li></ul><h2 id="Dense+Numbers">Dense Numbers<a href="#Dense+Numbers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Many typelevel constructs like <a href="https://harshad-deo.github.io/typequux/Covariant+Heterogenous+Lists.html">heterogenous lists</a> (and in this library, also <a href="https://harshad-deo.github.io/typequux/Type+Sets.html">type sets</a>, <a href="https://harshad-deo.github.io/typequux/Type+Maps.html">type maps</a>, <a href="https://harshad-deo.github.io/typequux/Singleton+Types+for+Literals.html">literal singleton types</a> and other constructs derived from them) rely on an encoding of natural numbers at the type level. While <a href="https://harshad-deo.github.io/typequux/Peano+Numbers.html">Peano numbers</a> are simple, their construction is too cumbersome and performance too poor for them to be suitable for most of the more complex constructs provided by the library.
</p><p>Functionally, dense numbers encode a numeric type in binary. A number is either 0 or a heterogenous list of digits. For non zero numbers, the <code>head</code> of the list is the least significant bit and the last element is always <code>1</code>. 
</p><pre><code class="prettyprint lang-scala">sealed trait Dense 
trait DCons[d &lt;: Dense.Digit, T &lt;: Dense] extends Dense
trait DNil extends Dense 

object Dense {

  sealed trait Digit 
  trait D0 extends Digit 
  trait D1 extends Digit 

  type ::[H &lt;: Digit, T &lt;: Dense] = DCons[H, T]

  type _0 = DNil
  type _1 = D1 :: DNil
  type _2 = D0 :: D1 :: DNil
  type _3 = D1 :: D1 :: DNil
  type _4 = D0 :: D0 :: D1 :: DNil
  type _5 = D1 :: D0 :: D1 :: DNil
  type _6 = D0 :: D1 :: D1 :: DNil
  type _7 = D1 :: D1 :: D1 :: DNil
  type _8 = D0 :: D0 :: D0 :: D1 :: DNil
  type _9 = D1 :: D0 :: D0 :: D1 :: DNil
}
</code></pre><p>By construction, left shift and right shift are constant time operations while all other times are log-time or worse. Therefore, in theory, indexers that use dense numbers are less efficient than those that use Peano numbers. In practice, the difference can be ignored and is compensated several times over by the performance gained in other operations. This is why typequux exclusively uses dense numbers to encode natural numbers into types. 
</p><p>The type signatures for dense numbers can be quite long and are not terribly informative. <code>/**/</code> represents an omitted (for clarity) type signature. 
</p><p>Some of the type constructors that are a part of the <code>Dense</code> trait are useful in practice. 
</p><h4 id="Increment">Increment<a href="#Increment" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import typequux._; import Dense._
import typequux._
import Dense._

scala&gt; implicitly[_0#Inc =:= _1]
res0: /**/ = &lt;function1&gt;

scala&gt; implicitly[_7#Inc =:= _8]
res2: /**/ = &lt;function1&gt;
</code></pre><h4 id="Decrement">Decrement<a href="#Decrement" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[_1#Dec =:= _0]
res3: /**/ = &lt;function1&gt;

scala&gt; implicitly[_16#Dec =:= _15]
res4: /**/ = &lt;function1&gt;
</code></pre><h4 id="Left+Shift">Left Shift<a href="#Left+Shift" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[_0#ShiftL =:= _0]
res5: /**/ = &lt;function1&gt;

scala&gt; implicitly[_1#ShiftL =:= _2]
res6: /**/ = &lt;function1&gt;

scala&gt; implicitly[_3#ShiftL =:= _6]
res7: /**/ = &lt;function1&gt;
</code></pre><h4 id="Right+Shift">Right Shift<a href="#Right+Shift" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[_0#ShiftR =:= _0]
res8: /**/ = &lt;function1&gt;

scala&gt; implicitly[_1#ShiftR =:= _0]
res9: /**/ = &lt;function1&gt;

scala&gt; implicitly[_2#ShiftR =:= _1]
res10: /**/ = &lt;function1&gt;

scala&gt; implicitly[_7#ShiftR =:= _3]
res11: /**/ = &lt;function1&gt;
</code></pre><p>The companion object provides type constructors that implement common operations. Supported operations are: 
</p><h4 id="Addition">Addition<a href="#Addition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[_2 + _3 =:= _5]
res12: /**/ = &lt;function1&gt;

scala&gt; implicitly[_6 + _0 =:= _6]
res13: /**/ = &lt;function1&gt;

scala&gt; implicitly[_0 + _2 =:= _2]
res14: /**/ = &lt;function1&gt;
</code></pre><h4 id="Multiplication">Multiplication<a href="#Multiplication" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[_4 * _0 =:= _0]
res15: =:=[typequux.Dense.*[typequux.Dense._4,typequux.Dense._0],typequux.Dense._0] = &lt;function1&gt;

scala&gt; implicitly[_7 * _1 =:= _7]
res16: =:=[typequux.Dense.*[typequux.Dense._7,typequux.Dense._1],typequux.Dense._7] = &lt;function1&gt;

scala&gt; implicitly[_3 * _4 =:= _12]
res17: =:=[typequux.Dense.*[typequux.Dense._3,typequux.Dense._4],typequux.Dense._12] = &lt;function1&gt;

scala&gt; implicitly[_4 * _4 =:= _16]
res18: =:=[typequux.Dense.*[typequux.Dense._4,typequux.Dense._4],typequux.Dense._16] = &lt;function1&gt;
</code></pre><h4 id="Exponentiation">Exponentiation<a href="#Exponentiation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[_5 ^ _0 =:= _1]
res19: /**/ = &lt;function1&gt;

scala&gt; implicitly[_7 ^ _1 =:= _7]
res20: /**/ = &lt;function1&gt;

scala&gt; implicitly[_1 ^ _4 =:= _1]
res21: /**/ = &lt;function1&gt;

scala&gt; implicitly[_3 ^ _2 =:= _9]
res22: /**/ = &lt;function1&gt;

scala&gt; implicitly[_2 ^ _4 =:= _16]
res23: /**/ = &lt;function1&gt;
</code></pre><h4 id="Comparators">Comparators<a href="#Comparators" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import typequux._ // package object, for True and False
import typequux._

scala&gt; implicitly[_0 &lt; _3 =:= True]
res26: /**/ = &lt;function1&gt;

scala&gt; implicitly[_5 &lt;= _5 =:= True]
res27: /**/ = &lt;function1&gt;

scala&gt; implicitly[_5 === _5 =:= True]
res28: /**/ = &lt;function1&gt;

scala&gt; implicitly[_5 === _7 =:= False]
res29: /**/ = &lt;function1&gt;

scala&gt; implicitly[_7 &gt; _4 =:= True]
res30: /**/ = &lt;function1&gt;

scala&gt; implicitly[_7 &gt;= _4 =:= True]
res31: /**/ = &lt;function1&gt;

scala&gt; implicitly[Max[_4, _5] =:= _5]
res32: /**/ = &lt;function1&gt;

scala&gt; implicitly[Min[_5, _9] =:= _5]
res33: /**/ = &lt;function1&gt;
</code></pre><h4 id="Subtraction">Subtraction<a href="#Subtraction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>It is implemented by a marker typeclass.
</p><pre><code class="prettyprint lang-scala">scala&gt; implicitly[DenseDiff[_0, _0, _0]]
res34: /**/ = /**/

scala&gt; implicitly[DenseDiff[_4, _0, _4]]
res35: /**/ = /**/

scala&gt; implicitly[DenseDiff[_13, _5, _8]]
res36: /**/ = /**/
</code></pre><h4 id="Value+Representation">Value Representation<a href="#Value+Representation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; Dense.toLong[_0]
res37: Long = 0

scala&gt; Dense.toLong[_16]
res38: Long = 16

scala&gt; Dense.toLong[_16 * _4]
res39: Long = 64
</code></pre><p>Dense numbers can be shown to satisfy: 
</p><ol><li>Additive Commutativity: <code>+[A, B] =:= +[B, A]</code>
</li><li>Multiplicative Commutativity: <code>*[A, B] =:= *[B, A]</code>
</li><li>Additive Associativity: <code>+[A, +[B, C]] =:= +[+[A, B], C]</code>
</li><li>Multiplicative Associativity: <code>*[A, *[B, C]] =:= *[*[A, B], C]</code>
</li><li>Distributivity: <code>*[+[A, B], C] =:= +[*[A, C], *[B, C]]</code>
</li><li>Additive Identity: <code>+[A, _0] =:= A</code>, <code>+[_0, A] =:= A</code>
</li><li>Multiplicative Identity: <code>*[A, _1] =:= A</code>, <code>*[_1, A] =:= A</code>
</li><li>Decrement of Increment: <code>A#Inc#Dec =:= A</code>
</li><li>Right Shift of Left Shift: <code>A#ShiftL#ShiftR =:= A</code>
</li><li>Left Shift: <code>A#ShiftL =:= *[A, _2]</code>
</li><li>Right Shift: <code>Xor[===[A, _2 * A#ShiftR], ===[A, *[_2, A#ShiftR] + _1]] =:= True</code>
</li><li>Exponent Combine 1: <code>*[A ^ B, A ^ C] =:= ^[A, B + C]</code>
</li><li>Exponent Combine 2: <code>^[A ^ B, C] =:= ^[A, B * C]</code>
</li><li>Exponent Combine 3: <code>*[A ^ C, B ^ C] =:= ^[A * B, C]</code>
</li><li>Exponent Identity: <code>^[A, _1] =:= A</code>
</li><li>Exponent Zero: <code>^[A, _0] =:= _1</code>
</li><li>Exponent One: <code>^[_1, A] =:= _1</code>
</li><li>Total Order
</li></ol><p>Refer to the <a href="https://github.com/harshad-deo/typequux/blob/master/src/test/scala/typequux/DenseSpec.scala">test cases</a> for examples
</p><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.Dense">API</a>
</li><li><a href="https://github.com/harshad-deo/typequux/blob/master/src/main/scala/typequux/Dense.scala">Source</a></li></ul><h2 id="Type+Sets">Type Sets<a href="#Type+Sets" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Type sets are implemented as binary trees of dense numbers. 
</p><pre><code class="prettyprint lang-scala">sealed trait DenseSet 
trait EmptyDenseSet extends DenseSet
trait NonEmptyDenseSet[V &lt;: Dense, L &lt;: DenseSet, R &lt;: DenseSet] extends DenseSet
</code></pre><p>You can use the type constructors that are a part of the DenseSet trait or (more conveniently), use the aliases defined in the companion object. Supported operations are: 
</p><h4 id="Include">Include<a href="#Include" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import typequux._; import typequux._, import Dense._; import DenseSet._
import typequux._
import typequux._
import Dense._
import DenseSet._

scala&gt; type S1 = EmptyDenseSet Include _7 Include _5 Include _2 Include _11
defined type alias S1

scala&gt; type S2 = EmptyDenseSet Include _7 Include _2 Include _5 Include _7
defined type alias S2

scala&gt; type S3 = EmptyDenseSet#Include[_7]#Include[_7]#Include[_2]#Include[_5]
defined type alias S3
</code></pre><h4 id="Contains">Contains<a href="#Contains" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[S1 Contains _7 =:= True]
res0: =:=[typequux.DenseSet.Contains[S1,typequux.Dense._7],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[S2 Contains _7 =:= True]
res1: =:=[typequux.DenseSet.Contains[S2,typequux.Dense._7],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[S2 Contains _0 =:= False]
res3: =:=[typequux.DenseSet.Contains[S2,typequux.Dense._0],typequux.False] = &lt;function1&gt;
</code></pre><h4 id="Remove">Remove<a href="#Remove" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; type S4 = S2 Remove _7
defined type alias S4

scala&gt; implicitly[S2 Contains _7 =:= True]
res8: =:=[typequux.DenseSet.Contains[S2,typequux.Dense._7],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[S4 Contains _7 =:= False]
res9: =:=[typequux.DenseSet.Contains[S4,typequux.Dense._7],typequux.False] = &lt;function1&gt;
</code></pre><h4 id="Union">Union<a href="#Union" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; type S5 = EmptyDenseSet Include _5 Include _11 Include _2 Include _18
defined type alias S5

scala&gt; type S6 = S2 Union S5
defined type alias S6

scala&gt; implicitly[S6 Contains _5 =:= True]
res10: =:=[typequux.DenseSet.Contains[S6,typequux.Dense._5],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[S6 Contains _2 =:= True]
res11: =:=[typequux.DenseSet.Contains[S6,typequux.Dense._2],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[S6 Contains _7 =:= True]
res12: =:=[typequux.DenseSet.Contains[S6,typequux.Dense._7],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[S6 Contains _18 =:= True]
res13: =:=[typequux.DenseSet.Contains[S6,typequux.Dense._18],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[S6 Contains _11 =:= True]
res14: =:=[typequux.DenseSet.Contains[S6,typequux.Dense._11],typequux.True] = &lt;function1&gt;
</code></pre><h4 id="Size">Size<a href="#Size" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The type of the dense number is not terribly informative. <code>/**/</code> is a type signature omitted for clarity.
</p><pre><code class="prettyprint lang-scala">cala&gt; implicitly[S1#Size =:= _4]
res15: /**/ = &lt;function1&gt;

scala&gt; implicitly[S2#Size =:= _3]
res16: /**/ = &lt;function1&gt;

scala&gt; implicitly[S4#Size =:= _2]
res17: /**/ = &lt;function1&gt;

scala&gt; implicitly[S5#Size =:= _4]
res18: /**/ = &lt;function1&gt;

scala&gt; implicitly[S6#Size =:= _5]
res19: /**/ = &lt;function1&gt;
</code></pre><h4 id="Equivalence">Equivalence<a href="#Equivalence" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[EmptyDenseSet Eq EmptyDenseSet =:= True]
res20: =:=[typequux.DenseSet.Eq[typequux.EmptyDenseSet,typequux.EmptyDenseSet],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[EmptyDenseSet Eq S1 =:= False]
res21: =:=[typequux.DenseSet.Eq[typequux.EmptyDenseSet,S1],typequux.False] = &lt;function1&gt;

scala&gt; implicitly[S2 Eq S3 =:= True]
res23: =:=[typequux.DenseSet.Eq[S2,S3],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[S1 Eq S2 =:= False]
res24: =:=[typequux.DenseSet.Eq[S1,S2],typequux.False] = &lt;function1&gt;
</code></pre><p>Since the specific type signature of a dense set depends on the path by which it was constructed, <code>=:=</code> should not be used to check whether two sets are equivalent. You should use the equivalence type constructor described above. 
</p><pre><code class="prettyprint lang-scala">scala&gt; type Eqv1 = EmptyDenseSet Include _3 Include _2 Include _9 Include _4 Include _16
defined type alias Eqv1

scala&gt; type Eqv2 = EmptyDenseSet Include _2 Include _3 Include _4 Include _9 Include _16
defined type alias Eqv2

scala&gt; implicitly[Eqv1 =:= Eqv2]
&lt;console&gt;:26: error: Cannot prove that Eqv1 =:= Eqv2.
       implicitly[Eqv1 =:= Eqv2]
                 ^

scala&gt; implicitly[Eqv1 Eq Eqv2 =:= True]
res26: =:=[typequux.DenseSet.Eq[Eqv1,Eqv2],typequux.True] = &lt;function1&gt;
</code></pre><p>Dense sets can be shown to satisfy: 
</p><ol><li>Union Identity: <code>True =:= Eq[X, X Union X]</code>
</li><li>Union Commutativity: <code>True =:= Eq[X Union Y, Y Union X]</code>
</li><li>Union Associativity: <code>True =:= Eq[Union[X, Union[Y, Z]], Union[Union[X, Y], Z]]</code>
</li></ol><p>Refer to the <a href="https://github.com/harshad-deo/typequux/blob/master/src/test/scala/typequux/DenseSetSpec.scala">test cases</a> for examples. Dense sets can be combined with singleton types for literals to do some interesting things. See the <a href="https://github.com/harshad-deo/typequux/blob/master/src/test/scala/typequux/DenseSetLiteralSpec.scala">test cases</a> for the same. 
</p><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://github.com/harshad-deo/typequux/blob/master/src/main/scala/typequux/DenseSet.scala">Source</a>
</li><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.DenseSet">API</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Church+Encoding+of+Booleans.html">Church Booleans</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Dense+Numbers.html">Dense Numbers</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Type+Maps.html">Type Maps</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Singleton+Types+for+Literals.html">Singleton Types for Literals</a></li></ul><h2 id="Type+Maps">Type Maps<a href="#Type+Maps" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Type maps are implemented as binary trees of key-value pairs in which the keys are dense numbers. 
</p><pre><code class="prettyprint lang-scala">sealed trait DenseMap
trait EmptyDenseMap extends DenseMap
trait NonEmptyDenseMap[KT &lt;: Dense, VT, L &lt;: DenseMap, R &lt;: DenseMap] extends DenseMap
</code></pre><p>You can use the type constructors that are a part of the DenseMap trait or (more conveniently), use the aliases defined in the companion object. Supported operations are: 
</p><h4 id="Add">Add<a href="#Add" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import typequux._; import typequux._; import Dense._; import DenseMap._
import typequux._
import typequux._
import Dense._
import DenseMap._

scala&gt; type G = EmptyDenseMap#Add[_5, Int]#Add[_6, String]#Add[_2, List[Int]]#Add[_9, Option[Long]]#Add[_4, Unit]
defined type alias G

scala&gt; type H = EmptyDenseMap#Add[_2, Int]#Add[_4, List[Int]]#Add[_0, None.type]
defined type alias H
</code></pre><h4 id="Contains">Contains<a href="#Contains" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[G Contains _5 =:= True]
res0: =:=[typequux.DenseMap.Contains[G,typequux.Dense._5],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[H Contains _7 =:= False]
res1: =:=[typequux.DenseMap.Contains[H,typequux.Dense._7],typequux.False] = &lt;function1&gt;

scala&gt; implicitly[H Contains _0 =:= True]
res2: =:=[typequux.DenseMap.Contains[H,typequux.Dense._0],typequux.True] = &lt;function1&gt;
</code></pre><h4 id="Get">Get<a href="#Get" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; implicitly[G Get _2 =:= List[Int]]
res3: =:=[typequux.DenseMap.Get[G,typequux.Dense._2],List[Int]] = &lt;function1&gt;

scala&gt; implicitly[G Get _4 =:= Unit]
res4: =:=[typequux.DenseMap.Get[G,typequux.Dense._4],Unit] = &lt;function1&gt;

scala&gt; implicitly[H Get _0 =:= None.type]
res5: =:=[typequux.DenseMap.Get[H,typequux.Dense._0],None.type] = &lt;function1&gt;
</code></pre><h4 id="Remove">Remove<a href="#Remove" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; type GR = G Remove _6
defined type alias GR

scala&gt; implicitly[G Contains _6 =:= True]
res6: =:=[typequux.DenseMap.Contains[G,typequux.Dense._6],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[GR Contains _6 =:= False]
res8: =:=[typequux.DenseMap.Contains[GR,typequux.Dense._6],typequux.False] = &lt;function1&gt;
</code></pre><h4 id="Union">Union<a href="#Union" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; type J = G Union H
defined type alias J

scala&gt; implicitly[J Contains _9 =:= True]
res9: =:=[typequux.DenseMap.Contains[J,typequux.Dense._9],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[J Contains _0 =:= True]
res10: =:=[typequux.DenseMap.Contains[J,typequux.Dense._0],typequux.True] = &lt;function1&gt;
</code></pre><h4 id="Keyset">Keyset<a href="#Keyset" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; type GKS = G#Keyset
defined type alias GKS

scala&gt; type HKS = H#Keyset
defined type alias HKS

scala&gt; import DenseSet._
import DenseSet._

scala&gt; type GKST = EmptyDenseSet Include _5 Include _6 Include _2 Include _9 Include _4
defined type alias GKST

scala&gt; type HKST = EmptyDenseSet Include _2 Include _4 Include _0
defined type alias HKST

scala&gt; implicitly[GKS Eq GKST =:= True]
res11: =:=[typequux.DenseSet.Eq[GKS,GKST],typequux.True] = &lt;function1&gt;

scala&gt; implicitly[HKS Eq HKST =:= True]
res12: =:=[typequux.DenseSet.Eq[HKS,HKST],typequux.True] = &lt;function1&gt;
</code></pre><h4 id="Size.">Size.<a href="#Size." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The type of the dense number is not terribly informative. <code>/**/</code> is a type signature omitted for clarity.
</p><pre><code class="prettyprint lang-scala">scala&gt; implicitly[G#Size =:= _5]
res13: /**/ = &lt;function1&gt;

scala&gt; implicitly[H#Size =:= _3]
res14:/**/ = &lt;function1&gt;

scala&gt; implicitly[J#Size =:= _6]
res17: /**/ = &lt;function1&gt;
</code></pre><p>Since the specific type signature of a dense map depends on the path by which it was constructed, <code>=:=</code> should not be used to check whether two dense maps are equivalent. For the same reason, if you take the union of two dense sets that have a different value associated with the same key, the value associated with a key in the resultant map will depend on the history of the two maps. Therefore, it is not possible to establish the sort of general laws regarding the union of two dense maps as it was for dense sets. 
</p><p>In the library, DenseMaps are used as backing datastructures for StringIndexedCollections and Records.
</p><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.DenseMap">API</a>
</li><li><a href="https://github.com/harshad-deo/typequux/blob/master/src/main/scala/typequux/DenseMap.scala">Source</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Type+Sets.html">Type Sets</a>
</li><li><a href="https://harshad-deo.github.io/typequux/String+Indexed+Collections.html">StringIndexedCollections</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Records.html">Records</a></li></ul><h2 id="Natural+Transformations">Natural Transformations<a href="#Natural+Transformations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://github.com/harshad-deo/typequux/blob/master/src/main/scala/typequux/Transform.scala">Source</a></li></ul><h2 id="Type-Unions+and+Exclusions">Type-Unions and Exclusions<a href="#Type-Unions+and+Exclusions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://github.com/harshad-deo/typequux/blob/master/src/main/scala/typequux/Contained.scala">Source</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Covariant+Heterogenous+Lists.html">HList</a></li></ul><h2 id="Singleton+Types+for+Literals">Singleton Types for Literals<a href="#Singleton+Types+for+Literals" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.LiteralHash">API</a>
</li><li><a href="https://github.com/harshad-deo/typequux/tree/master/src/main/scala/typequux/LiteralHash.scala">Source</a></li></ul><h2 id="Covariant+Heterogenous+Lists">Covariant Heterogenous Lists<a href="#Covariant+Heterogenous+Lists" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>TypeQuux ships with a rich API for operating on heterogenous lists and subsumes operations typically associated with klists. Operations that would result in runtime errors (mostly) do not compile. All indexed operations (<code>apply</code>, <code>drop</code>, <code>take</code> etc) are 0-based and can be indexed from the left or the right.
</p><p>The type signatures for hlists can be quite long and are not terribly informative in the examples presented below. <code>/**/</code> represents an omitted (for clarity) type signature. 
</p><h4 id="Covariance">Covariance<a href="#Covariance" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import typequux._ // package
import typequux._

scala&gt; import typequux._ // package object
import typequux._

scala&gt; type LT = String :+: AnyVal :+: AnyRef :+: Traversable[_] :+: Option[Int] :+: HNil
defined type alias LT

scala&gt; type ST = String :+: Long :+: Set[Double] :+: List[Int] :+: None.type :+: HNil
defined type alias ST

scala&gt; implicitly[ST &lt;:&lt; LT] // compiles
res0: &lt;:&lt;[ST,LT] = &lt;function1&gt;

scala&gt; val a =  &quot;mmm&quot; :+: 42L :+: Set(3.14, 2.718) :+: List(1, 2, 3) :+: None :+: HNil
a: /**/ = mmm :+: 42 :+: Set(3.14, 2.718) :+: List(1, 2, 3) :+: None :+: HNil

scala&gt; val l: LT = a
l: LT = mmm :+: 42 :+: Set(3.14, 2.718) :+: List(1, 2, 3) :+: None :+: HNil

scala&gt; val s: ST = a
s: ST = mmm :+: 42 :+: Set(3.14, 2.718) :+: List(1, 2, 3) :+: None :+: HNil
</code></pre><h4 id="You+can+concatenate+them">You can concatenate them<a href="#You+can+concatenate+them" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val a = 3 :+: &quot;ai4&quot; :+: List('r', 'h') :+: HNil; val b = '3' :+: 2 :+: 'j' :+: &quot;sdfh&quot; :+: HNil
a: /**/ = 3 :+: ai4 :+: List(r, h) :+: HNil
b: /**/ = 3 :+: 2 :+: j :+: sdfh :+: HNil

scala&gt; val ab = a :++: b
ab: /**/ = 3 :+: ai4 :+: List(r, h) :+: 3 :+: 2 :+: j :+: sdfh :+: HNil
</code></pre><h4 id="You+can+reverse+them">You can reverse them<a href="#You+can+reverse+them" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val x = &quot;str&quot; :+: true :+: 1 :+: Some(3.14) :+: HNil
x: /**/ = str :+: true :+: 1 :+: Some(3.14) :+: HNil

scala&gt; val xr = x.reverse
xr: /**/ = Some(3.14) :+: 1 :+: true :+: str :+: HNil

scala&gt; val xrr = xr.reverse
xrr: /**/ = str :+: true :+: 1 :+: Some(3.14) :+: HNil

scala&gt; x == xrr
res26: Boolean = true
</code></pre><h4 id="They+support+value+level+length">They support value level length<a href="#They+support+value+level+length" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val hl1 = true :+: &quot;foo&quot; :+: 2 :+: Some(&quot;one is waiting for you&quot;) :+: HNil
hl1: /**/ = true :+: foo :+: 2 :+: Some(one is waiting for you) :+: HNil

scala&gt; hl1.length
res1: Long = 4

scala&gt; HNil.length
res2: Long = 0
</code></pre><h4 id="You+can+select+an+element+using+an+integer+index">You can select an element using an integer index<a href="#You+can+select+an+element+using+an+integer+index" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val p = 3 :+: true :+: &quot;asdf&quot; :+: false :+: 'k' :+: () :+: 13 :+: 9.3 :+: HNil
p: /**/ = 3 :+: true :+: asdf :+: false :+: k :+: () :+: 13 :+: 9.3 :+: HNil

scala&gt; p(0) // note that the type information is preserved
res3: Int = 3

scala&gt; p(4)
res4: Char = k

scala&gt; p.right(0)
res5: Double = 9.3

scala&gt; p.right(6)
res6: Boolean = true

scala&gt; p(100) // does not compile
</code></pre><h4 id="You+can+drop+elements.">You can drop elements.<a href="#You+can+drop+elements." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The arguments is the number of elements to drop.
</p><pre><code class="prettyprint lang-scala">scala&gt; p.drop(0)
res7: /**/ = 3 :+: true :+: asdf :+: false :+: k :+: () :+: 13 :+: 9.3 :+: HNil

scala&gt; p.drop(4)
res8: /**/ = k :+: () :+: 13 :+: 9.3 :+: HNil

scala&gt; p.dropRight(4)
res10: /**/ = 3 :+: true :+: asdf :+: false :+: HNil

scala&gt; p.dropRight(6)
res12: /**/ = 3 :+: true :+: HNil
</code></pre><h4 id="You+can+take+elements.">You can take elements.<a href="#You+can+take+elements." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The argument is the number of elements to take.
</p><pre><code class="prettyprint lang-scala">scala&gt; p.take(0)
res13: /**/ = HNil

scala&gt; p.take(4)
res14: /**/ = 3 :+: true :+: asdf :+: false :+: HNil

scala&gt; p.takeRight(4)
res15: /**/ = k :+: () :+: 13 :+: 9.3 :+: HNil

scala&gt; p.takeRight(8)
res16: /**/ = 3 :+: true :+: asdf :+: false :+: k :+: () :+: 13 :+: 9.3 :+: HNil
</code></pre><h4 id="You+can+update+individual+elements">You can update individual elements<a href="#You+can+update+individual+elements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val m = &quot;p&quot; :+: 3 :+: 't' :+: Some(&quot;is&quot;) :+: HNil
m: /**/ = p :+: 3 :+: t :+: Some(is) :+: HNil

scala&gt; m.updated(2, 110)
res20: /**/ = p :+: 3 :+: 110 :+: Some(is) :+: HNil

scala&gt; m.updated(0, 2.718)
res21: /**/ = 2.718 :+: 3 :+: t :+: Some(is) :+: HNil

scala&gt; m.updatedRight(0, List(&quot;dogs&quot;, &quot;cats&quot;))
res22: /**/ = p :+: 3 :+: t :+: List(dogs, cats) :+: HNil

scala&gt; m.updatedRight(2, None)
res24: /**/ = p :+: None :+: t :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+remove+an+element">You can remove an element<a href="#You+can+remove+an+element" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; m.remove(0)
res28: /**/ = 3 :+: t :+: Some(is) :+: HNil

scala&gt; m.remove(3)
res29: /**/ = p :+: 3 :+: t :+: HNil

scala&gt; m.removeRight(0)
res30: /**/ = p :+: 3 :+: t :+: HNil

scala&gt; m.removeRight(2)
res31: /**/ = p :+: t :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+map+an+element">You can map an element<a href="#You+can+map+an+element" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; m.indexMap(1, (i: Int) =&gt; i &lt;&lt; 2)
res34: /**/ = p :+: 12 :+: t :+: Some(is) :+: HNil

scala&gt; m.indexMapRight(1, (c: Char) =&gt; (c.toInt, c))
res35: /**/ = p :+: 3 :+: (116,t) :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+flatmap+an+element">You can flatmap an element<a href="#You+can+flatmap+an+element" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">m.indexFlatMap(2, (c: Char) =&gt; c.toInt :+: (c.toString + &quot;asty&quot; :+: HNil))
res38: /**/ = p :+: 3 :+: 116 :+: tasty :+: Some(is) :+: HNil

scala&gt; m.indexFlatMapRight(1, (c: Char) =&gt; Some(c.toString + &quot;ense&quot;) :+: &quot;Negotiations&quot; :+: 42 :+: HNil)
res39: /**/ = p :+: 3 :+: Some(tense) :+: Negotiations :+: 42 :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+insert+an+element.">You can insert an element.<a href="#You+can+insert+an+element." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The index is the position at which the inserted element will go. 
</p><pre><code class="prettyprint lang-scala">scala&gt; m.insert(0, 3.14159)
res41: /**/ = 3.14159 :+: p :+: 3 :+: t :+: Some(is) :+: HNil

scala&gt; m.insert(2, &quot;2.718&quot;)
res42: /**/ = p :+: 3 :+: 2.718 :+: t :+: Some(is) :+: HNil

scala&gt; m.insertRight(0, Some(6.62607))
res43: /**/ = p :+: 3 :+: t :+: Some(is) :+: Some(6.62607) :+: HNil

scala&gt; m.insertRight(1, None)
res44: /**/ = p :+: 3 :+: t :+: None :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+insert+a+hlist.">You can insert a hlist.<a href="#You+can+insert+a+hlist." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The index is the position at which the head of the inserted hlist will go. 
</p><pre><code class="prettyprint lang-scala">scala&gt; m.insertM(0, true :+: &quot;foo&quot; :+: HNil)
res45: /**/ = true :+: foo :+: p :+: 3 :+: t :+: Some(is) :+: HNil

scala&gt; m.insertM(2, true :+: &quot;foo&quot; :+: HNil)
res46: /**/ = p :+: 3 :+: true :+: foo :+: t :+: Some(is) :+: HNil

scala&gt; m.insertMRight(0, true :+: &quot;foo&quot; :+: HNil) // essentially concatenation
res47: /**/ = p :+: 3 :+: t :+: Some(is) :+: true :+: foo :+: HNil

scala&gt; m.insertMRight(2, true :+: &quot;foo&quot; :+: HNil) 
res48: /**/ = p :+: 3 :+: true :+: foo :+: t :+: Some(is) :+: HNil
</code></pre><h4 id="You+can+split+at+an+index">You can split at an index<a href="#You+can+split+at+an+index" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val w = 3 :+: true :+: &quot;asdf&quot; :+: 'k' :+: () :+: 9.3 :+: HNil
w: /**/ = 3 :+: true :+: asdf :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.splitAt(0)
res50: /**/ = (HNil,3 :+: true :+: asdf :+: k :+: () :+: 9.3 :+: HNil)

scala&gt; w.splitAt(3)
res51: /**/ = (3 :+: true :+: asdf :+: HNil,k :+: () :+: 9.3 :+: HNil)

scala&gt; w.splitAtRight(2)
res53: /**/ = (3 :+: true :+: asdf :+: k :+: HNil,() :+: 9.3 :+: HNil)

scala&gt; w.splitAtRight(4)
res54: /**/ = (3 :+: true :+: HNil,asdf :+: k :+: () :+: 9.3 :+: HNil)
</code></pre><h4 id="You+can+index+an+hlist+with+a+type.">You can index an hlist with a type.<a href="#You+can+index+an+hlist+with+a+type." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Type-indexes support <code>at</code>, <code>take</code>, <code>drop</code>, <code>update</code>, <code>remove</code>, <code>map</code>, <code>flatmap</code>, <code>element insertion</code>, <code>hlist insertion</code> and <code>splitAt</code>
</p><pre><code class="prettyprint lang-scala">scala&gt; w.t[String].at
res55: String = asdf

scala&gt; w.t[String].before
res56: /**/ = 3 :+: true :+: HNil

scala&gt; w.t[String].after
res57: /**/ = k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[String].drop
res58: /**/ = asdf :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[String].take
res59: /**/ = 3 :+: true :+: HNil

scala&gt; w.t[String].updated(19)
res60: /**/ = 3 :+: true :+: 19 :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[Unit].remove
res61: /**/ = 3 :+: true :+: asdf :+: k :+: 9.3 :+: HNil

scala&gt; w.t[Char].map(_.isUpper)
res62: /**/ = 3 :+: true :+: asdf :+: false :+: () :+: 9.3 :+: HNil

scala&gt; w.t[String].flatMap(s =&gt; s(0) :+: s.substring(1) :+: HNil)
res63: /**/ = 3 :+: true :+: a :+: sdf :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[String].insert(Some(4.4))
res64: /**/ = 3 :+: true :+: Some(4.4) :+: asdf :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[String].insertM(Some(true) :+: None :+: HNil)
res65: /**/ = 3 :+: true :+: Some(true) :+: None :+: asdf :+: k :+: () :+: 9.3 :+: HNil

scala&gt; w.t[Char].splitAt
res66: /**/ = (3 :+: true :+: asdf :+: HNil,k :+: () :+: 9.3 :+: HNil)
</code></pre><p>When indexing by type, if  case multiple elements have the indexed type, the element furthest to the right is selected
</p><pre><code class="prettyprint lang-scala">scala&gt; val ti = 3.14159 :+: &quot;john&quot; :+: List(&quot;puppy, kitten&quot;) :+: Some(&quot;snow&quot;) :+: &quot;ramsay&quot; :+: (22L, 11.14) :+: HNil
ti: /**/ = 3.14159 :+: john :+: List(puppy, kitten) :+: Some(snow) :+: ramsay :+: (22,11.14) :+: HNil

scala&gt; ti.t[String].at
res68: String = ramsay
</code></pre><h4 id="You+can+zip+two+hlists+together.">You can zip two hlists together.<a href="#You+can+zip+two+hlists+together." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The length of the resulting list is the minimum of the length of the originals
</p><pre><code class="prettyprint lang-scala">scala&gt; val rz = 3 :+: &quot;ai4&quot; :+: List('r', 'H') :+: HNil; val sz = '3' :+: 2 :+: 'j' :+: &quot;sdfh&quot; :+: HNil
rz: /**/ = 3 :+: ai4 :+: List(r, H) :+: HNil
sz: /**/ = 3 :+: 2 :+: j :+: sdfh :+: HNil

scala&gt; rz zip sz
res69: /**/ = (3,3) :+: (ai4,2) :+: (List(r, H),j) :+: HNil

scala&gt; sz zip rz
res70: /**/ = (3,3) :+: (2,ai4) :+: (j,List(r, H)) :+: HNil

scala&gt; rz zip sz.tail
res71: /**/ = (3,2) :+: (ai4,j) :+: (List(r, H),sdfh) :+: HNil
</code></pre><h4 id="If+each+element+of+a+hlist+is+a+tuple2%2C+you+can+unzip+it">If each element of a hlist is a tuple2, you can unzip it<a href="#If+each+element+of+a+hlist+is+a+tuple2%2C+you+can+unzip+it" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val tpls = (1, true) :+: (Some(&quot;string&quot;), &quot;99 bottles of beer on the wall&quot;) :+: (&quot;oogachaka&quot;, 42L) :+: HNil
tpls: /**/ = (1,true) :+: (Some(string),99 bottles of beer on the wall) :+: (oogachaka,42) :+: HNil

scala&gt; tpls.unzip
res72: /**/ = (1 :+: Some(string) :+: oogachaka :+: HNil,true :+: 99 bottles of beer on the wall :+: 42 :+: HNil)
</code></pre><h4 id="You+can+apply+natural+transformations+on+hlists">You can apply natural transformations on hlists<a href="#You+can+apply+natural+transformations+on+hlists" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val list2Option: List ~&gt; Option = new (List ~&gt; Option) {override def apply[T](x: List[T]) = x.headOption}
list2Option: /**/ = /**/

scala&gt; val hl1 = List(1, 2, 3) :+: List[Boolean]() :+: List(&quot;oogachaka&quot;, &quot;ho gaya&quot;) :+: HNil
hl1: /**/ = List(1, 2, 3) :+: List() :+: List(oogachaka, ho gaya) :+: HNil

scala&gt; hl1 transform list2Option
res73: /**/ = Some(1) :+: None :+: Some(oogachaka) :+: HNil

scala&gt; HNil transform list2Option
res74: /**/ = HNil
</code></pre><h4 id="You+can+down+convert+an+hlist">You can down convert an hlist<a href="#You+can+down+convert+an+hlist" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val list2Down: Vector ~&gt; Id = new (Vector ~&gt; Id) {override def apply[T](x: Vector[T]) = x(0)}
list2Down: /**/ = /**/

scala&gt; val hl2 = Vector(1, 2, 1) :+: Vector(true) :+: HNil
hl2: /**/ = Vector(1, 2, 1) :+: Vector(true) :+: HNil

scala&gt; hl2 down list2Down
res75: /**/ = 1 :+: true :+: HNil

scala&gt; HNil down list2Down
res76: /**/ = HNil
</code></pre><h4 id="You+can+apply+an+hlist+of+functions+to+a+hlist+of+arguments.">You can apply an hlist of functions to a hlist of arguments.<a href="#You+can+apply+an+hlist+of+functions+to+a+hlist+of+arguments." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Or you could yoda-apply it for kicks.
</p><pre><code class="prettyprint lang-scala">scala&gt; val y1 = 9.75 :+: 'x' :+: HNil
y1: /**/ = 9.75 :+: x :+: HNil

scala&gt; val y2 = -2.125 :+: 'X' :+: HNil
y2: /**/ = -2.125 :+: X :+: HNil

scala&gt; val f = ((x: Double) =&gt; x + 5) :+: ((x: Char) =&gt; x.isUpper) :+: HNil
f: /**/ = &lt;function1&gt; :+: &lt;function1&gt; :+: HNil

scala&gt;  f fapply y1
res77: /**/ = 14.75 :+: false :+: HNil

scala&gt;  f fapply y2
res78: /**/ = 2.875 :+: true :+: HNil

scala&gt;  y1 yapply f // yoda-application: to the data, apply the function
res79: /**/ = 14.75 :+: false :+: HNil

scala&gt;  y2 yapply f
res80: /**/ = 2.875 :+: true :+: HNil
</code></pre><h4 id="You+can+perform+arbitrary+arity+zips+and+zipwiths+with+hlists">You can perform arbitrary arity zips and zipwiths with hlists<a href="#You+can+perform+arbitrary+arity+zips+and+zipwiths+with+hlists" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val sz1 = List(1, 2, 3) :+: List(true, false) :+: HNil
sz1: /**/ = List(1, 2, 3) :+: List(true, false) :+: HNil

scala&gt; val sz2 = Vector(1, 2, 3) :+: Vector(true, false) :+: Vector(&quot;alpha&quot;, &quot;beta&quot;, &quot;charlie&quot;, &quot;delta&quot;) :+: Vector(3.14, 2.718, 6.262) :+: HNil
sz2: /**/ = Vector(1, 2, 3) :+: Vector(true, false) :+: Vector(alpha, beta, charlie, delta) :+: Vector(3.14, 2.718, 6.262) :+: HNil

scala&gt; sz1.azipped
res81: /**/ = List(1 :+: true :+: HNil, 2 :+: false :+: HNil)

scala&gt; sz2.azipped
res82: /**/ = Vector(1 :+: true :+: alpha :+: 3.14 :+: HNil, 2 :+: false :+: beta :+: 2.718 :+: HNil)

scala&gt; sz1.zipwith { case i :+: b :+: _ =&gt; (b, i) } 
res83: List[(Boolean, Int)] = List((true,1), (false,2))

scala&gt; sz2.zipwith { case i :+: b :+: s :+: d :+: _ =&gt; ((i, s), (b, d))}
res84: scala.collection.immutable.Vector[((Int, String), (Boolean, Double))] = Vector(((1,alpha),(true,3.14)), ((2,beta),(false,2.718)))

scala&gt; val fibs: Stream[BigInt] = BigInt(0) #:: BigInt(1) #:: fibs.zip(fibs.tail).map { n =&gt; n._1 + n._2}
fibs: Stream[BigInt] = Stream(0, ?)

scala&gt; val nats: Stream[Int] = Stream.from(1)
nats: Stream[Int] = Stream(1, ?)

scala&gt; val pows: Stream[Long] = {def go(n: Int): Stream[Long] = (1L &lt;&lt; n) #:: go(n + 1); go(1) }
pows: Stream[Long] = Stream(2, ?)

scala&gt; val fz1 = fibs :+: nats :+: HNil
fz1: /**/ = Stream(0, ?) :+: Stream(1, ?) :+: HNil

scala&gt; val fz2 = fibs :+: nats :+: pows :+: HNil
fz2: /**/ = Stream(0, ?) :+: Stream(1, ?) :+: Stream(2, ?) :+: HNil

scala&gt; val fz3 = fibs :+: nats :+: Stream.empty[String] :+: HNil
fz3: /**/ = Stream(0, ?) :+: Stream(1, ?) :+: Stream() :+: HNil

scala&gt; fz1.azipped
res85: /**/ = Stream(0 :+: 1 :+: HNil, ?)

scala&gt; (res85 take 5).toList
res87: /**/ = List(0 :+: 1 :+: HNil, 1 :+: 2 :+: HNil, 1 :+: 3 :+: HNil, 2 :+: 4 :+: HNil, 3 :+: 5 :+: HNil)

scala&gt; fz2.azipped
res88: /**/ = Stream(0 :+: 1 :+: 2 :+: HNil, ?)

scala&gt; (res88 take 3).toVector
res89: /**/ = Vector(0 :+: 1 :+: 2 :+: HNil, 1 :+: 2 :+: 4 :+: HNil, 1 :+: 3 :+: 8 :+: HNil)

scala&gt; fz3.azipped
res90: /**/ = Stream()

scala&gt; fz1.zipwith { case b :+: i :+: _ =&gt; (i, b) }
res91: Stream[(Int, BigInt)] = Stream((1,0), ?)

scala&gt; (res91 take 3).toArray
res92: Array[(Int, BigInt)] = Array((1,0), (2,1), (3,1))

scala&gt; fz2.zipwith { case b :+: i :+: l :+: _ =&gt; (i, (b, l)) }
res93: Stream[(Int, (BigInt, Long))] = Stream((1,(0,2)), ?)

scala&gt; (res93 take 3).toList
res94: List[(Int, (BigInt, Long))] = List((1,(0,2)), (2,(1,4)), (3,(1,8)))

scala&gt; fz3.zipwith { case b :+: i :+: s :+: _ =&gt; (i, b, s) }
res95: Stream[(Int, BigInt, String)] = Stream()
</code></pre><h4 id="Common+View+Operations">Common View Operations<a href="#Common+View+Operations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Provided that there exists an implicit conversion to a common type for each element type of a hlist, you can use <code>foreach</code>, <code>count</code>, <code>exists</code>, <code>forall</code> and <code>foldleft</code> as you would with a standard library list.
</p><pre><code class="prettyprint lang-scala">scala&gt; import language.implicitConversions
import language.implicitConversions

scala&gt; :paste
// Entering paste mode (ctrl-D to finish)

trait Lengthable {
  def length: Int
}
object Lengthable {
  implicit def int2Lengthable(i: Int): Lengthable = new Lengthable {
    override def length = i
  }
  implicit def string2Lengthable(s: String): Lengthable = new Lengthable {
    override def length = s.length
  }
  implicit def seq2Lengthable[T](s: Seq[T]): Lengthable = new Lengthable {
    override def length = s.length
  }
  implicit def bool2Lengthable(b: Boolean): Lengthable = new Lengthable {
    override def length = if (b) 1 else 0
  }
  implicit def tuple2Lengthable[T, U](t: (T, U))(implicit ev0: T =&gt; Lengthable, ev1: U =&gt; Lengthable): Lengthable =
    new Lengthable {
      override def length = t._1.length * t._2.length
    }
}

// Exiting paste mode, now interpreting.

defined trait Lengthable
defined object Lengthable

scala&gt; val cvt = 3 :+: &quot;oogachaka&quot; :+: List(1, 2, 3) :+: Vector(&quot;cow&quot;, &quot;chicken&quot;) :+: false :+: (5, &quot;ho gaya&quot;) :+: HNil
cvt: /**/ = 3 :+: oogachaka :+: List(1, 2, 3) :+: Vector(cow, chicken) :+: false :+: (5,ho gaya) :+: HNil

scala&gt; var maxl = 0
maxl: Int = 0

scala&gt; cvt.foreach[Lengthable](l =&gt; maxl = math.max(maxl, l.length))

scala&gt; maxl
res98: Int = 35

scala&gt; cvt.exists[Lengthable](_.length &lt; 10)
res99: Boolean = true

scala&gt; cvt.forall[Lengthable](_.length &gt;= 0)
res100: Boolean = true

scala&gt; cvt.forall[Lengthable](_.length &gt; 0)
res101: Boolean = false

scala&gt; cvt.count[Lengthable](_.length &gt; 5)
res102: Int = 2

scala&gt; cvt.foldLeft[Int, Lengthable](0)(_ + _.length)
res103: Int = 52
</code></pre><h4 id="They+can+be+converted+to+regular+lists">They can be converted to regular lists<a href="#They+can+be+converted+to+regular+lists" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The element type of the list is the least upper bound of the element types of the HList
</p><pre><code class="prettyprint lang-scala">scala&gt; val hlc1 = 42 :+: 22L :+: 3.14159 :+: 'c' :+: 2.718f :+: HNil
hlc1: /**/ = 42 :+: 22 :+: 3.14159 :+: c :+: 2.718 :+: HNil

scala&gt; hlc1.toList
res105: List[AnyVal] = List(42, 22, 3.14159, c, 2.718)

scala&gt; val hlc2 = List(1, 2, 3) :+: List(true, false) :+: HNil 
hlc2: /**/ = List(1, 2, 3) :+: List(true, false) :+: HNil

scala&gt; hlc2.toList
res106: List[List[AnyVal]] = List(List(1, 2, 3), List(true, false))

scala&gt; val hlc3 = Some(&quot;foo&quot;) :+: Some(Set(1, 2,3)) :+: HNil
hlc3: /**/ = Some(foo) :+: Some(Set(1, 2, 3)) :+: HNil

scala&gt; hlc3.toList
res107: List[Some[Object]] = List(Some(foo), Some(Set(1, 2, 3)))

scala&gt; val hlc4 = Some(&quot;foo&quot;) :+: Some(Set(1, 2,3)) :+: None :+: HNil
hlc4: /**/ = Some(foo) :+: Some(Set(1, 2, 3)) :+: None :+: HNil

scala&gt; hlc4.toList
res109: List[Option[Object]] = List(Some(foo), Some(Set(1, 2, 3)), None)
</code></pre><h3 id="See+also">See also<a href="#See+also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.HList">API</a>
</li><li><a href="https://github.com/harshad-deo/typequux/blob/master/src/main/scala/typequux/HList.scala">Source</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Records.html">Records</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Understanding+Constraints.html">Constraints</a>
</li></ul><h2 id="Tuple+Ops">Tuple Ops<a href="#Tuple+Ops" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Tuples support the same operations as hlists. This is achieved by converting the tuple to an hlist, performing the corresponding operation on the hlist and converting back the result. Therefore the performance of an operation on a tuple will be strictly worse than that of the operation on the corresponding hlist. However, tuples <em>are</em> a part of the standard scala library, will be more interoperable with the rest of your codebase and code that uses tuples is, by virtue of familiarity, easier to parse. So unless profiling shows that an hlist-style operation is the bottleneck (which will almost never be the case), feel free to use the operations listed. 
</p><p>As with hlists, all indexed operations (<code>apply</code>, <code>drop</code>, <code>take</code> etc) are 0-based and can be indexed from the left or the right. The type signatures for the tuples aren’t terribly informative in the examples presented below. For clarity, <code>/**/</code> represents an omitted type signature. 
</p><h4 id="You+can+%E2%80%9Ccons%E2%80%9D+an+element+onto+a+tuple.">You can “cons” an element onto a tuple.<a href="#You+can+%E2%80%9Ccons%E2%80%9D+an+element+onto+a+tuple." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import typequux._; import TupleOps._
import typequux._
import TupleOps._

scala&gt; 22l :*: (&quot;str&quot;, true, 1, Some(3.14))
res0: /**/ = (22,str,true,1,Some(3.14))

scala&gt; 3.14 :*: None :*: res0
res1: /**/ = (3.14,None,22,str,true,1,Some(3.14))
</code></pre><h4 id="You+can+append+two+tuples.">You can append two tuples.<a href="#You+can+append+two+tuples." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val t1 = (Some(3.14), 1, true, &quot;str&quot;); val t2 = ('3', 2, &quot;sdfg&quot;)
t1: /**/ = (Some(3.14),1,true,str)
t2: /**/ = (3,2,sdfg)

scala&gt; val t3 = t1 :**: t2
t3: /**/ = (Some(3.14),1,true,str,3,2,sdfg)
</code></pre><h4 id="You+can+reverse+tuples.">You can reverse tuples.<a href="#You+can+reverse+tuples." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; t1.reverse
res3: /**/ = (str,true,1,Some(3.14))

scala&gt; t2.reverse
res4: /**/ = (sdfg,2,3)

scala&gt; t3.reverse
res5: /**/ = (sdfg,2,3,str,true,1,Some(3.14))

scala&gt; t1.reverse.reverse == t1
res10: Boolean = true

scala&gt; t2.reverse.reverse == t2
res11: Boolean = true

scala&gt; t3.reverse.reverse == t3
res12: Boolean = true
</code></pre><h4 id="You+can+get+an+integer+representation+of+its+arity.">You can get an integer representation of its arity.<a href="#You+can+get+an+integer+representation+of+its+arity." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; t1.length
res13: Long = 4

scala&gt; t2.length
res14: Long = 3

scala&gt; t3.length
res15: Long = 7
</code></pre><h4 id="You+can+select+an+element+using+an+integer+index.">You can select an element using an integer index.<a href="#You+can+select+an+element+using+an+integer+index." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val p = (3, true, &quot;asdf&quot;, false, 'k', (), 13, 9.3)
p: /**/ = (3,true,asdf,false,k,(),13,9.3)

scala&gt; p(0)
res21: Int = 3

scala&gt; p(3)
res22: Boolean = false

scala&gt; p.right(0)
res23: Double = 9.3

scala&gt; p.right(1)
res25: Int = 13
</code></pre><h4 id="You+can+drop+elements.">You can drop elements.<a href="#You+can+drop+elements." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The argument is the number of elements to drop.
</p><pre><code class="prettyprint lang-scala">scala&gt; p.drop(3)
res26: /**/ = (false,k,(),13,9.3)

scala&gt; p.dropRight(2)
res27: /**/ = (3,true,asdf,false,k,())
</code></pre><h4 id="You+can+take+elements.">You can take elements.<a href="#You+can+take+elements." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The argument is the number of elements to take.
</p><pre><code class="prettyprint lang-scala">scala&gt; p.take(2)
res28: /**/ = (3,true)

scala&gt; p.takeRight(4)
res29: /**/ = (k,(),13,9.3)
</code></pre><h4 id="You+can+update+individual+elements">You can update individual elements<a href="#You+can+update+individual+elements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; p.updated(0, None)
res30: /**/ = (None,true,asdf,false,k,(),13,9.3)

scala&gt; p.updated(2, List(true, false))
res31: /**/ = (3,true,List(true, false),false,k,(),13,9.3)

scala&gt; p.updatedRight(0, &quot;oogachaka&quot;)
res32: /**/ = (3,true,asdf,false,k,(),13,oogachaka)

scala&gt; p.updatedRight(3, 42)
res33: /**/ = (3,true,asdf,false,42,(),13,9.3)
</code></pre><h4 id="You+can+remove+an+element">You can remove an element<a href="#You+can+remove+an+element" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; p.remove(0)
res34: /**/ = (true,asdf,false,k,(),13,9.3)

scala&gt; p.remove(4)
res35: /**/ = (3,true,asdf,false,(),13,9.3)

scala&gt; p.removeRight(0)
res36: /**/ = (3,true,asdf,false,k,(),13)

scala&gt; p.removeRight(2)
res37: /**/ = (3,true,asdf,false,k,13,9.3)
</code></pre><h4 id="You+can+map+an+element">You can map an element<a href="#You+can+map+an+element" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val m = (&quot;p&quot;, 3, 't', List(&quot;puppies&quot;, &quot;kittens&quot;, &quot;goat&quot;), Some(&quot;is&quot;))
m: /**/ = (p,3,t,List(puppies, kittens, goat),Some(is))

scala&gt; m.indexMap(1, (i: Int) =&gt; i &lt;&lt; 2)
res42: /**/ = (p,12,t,List(puppies, kittens, goat),Some(is))

scala&gt; m.indexMapRight(2, (c: Char) =&gt; c.toInt)
res43: /**/ = (p,3,116,List(puppies, kittens, goat),Some(is))
</code></pre><h4 id="You+can+flatmap+an+element">You can flatmap an element<a href="#You+can+flatmap+an+element" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>So long as a tuple of the resulting arity can be constructed.
</p><pre><code class="prettyprint lang-scala">scala&gt; m.indexFlatMap(2, (c: Char) =&gt; (c, c.toInt, c.toString + &quot;ype quux&quot;))
res44: /**/ = (p,3,t,116,type quux,List(puppies, kittens, goat),Some(is))

scala&gt; m.indexFlatMapRight(1, (l: List[String]) =&gt; (l.length, l.filter(_.length &gt; 4), l.map(s =&gt; Some(s))))
res50: /**/ = (p,3,t,3,List(puppies, kittens),List(Some(puppies), Some(kittens), Some(goat)),Some(is))
</code></pre><h4 id="You+can+insert+an+element.">You can insert an element.<a href="#You+can+insert+an+element." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The index is the position at which the inserted element will go.
</p><pre><code class="prettyprint lang-scala">scala&gt; m.insert(0, None)
res52: /**/ = (None,p,3,t,List(puppies, kittens, goat),Some(is))

scala&gt; m.insert(2, Some(42))
res53: /**/ = (p,3,Some(42),t,List(puppies, kittens, goat),Some(is))

scala&gt; m.insertRight(0, None)
res54: /**/ = (p,3,t,List(puppies, kittens, goat),Some(is),None)

scala&gt; m.insertRight(2, List(0, 1, 1, 2, 3, 5, 8))
res55: /**/ = (p,3,t,List(0, 1, 1, 2, 3, 5, 8),List(puppies, kittens, goat),Some(is))
</code></pre><h4 id="You+can+insert+a+tuple.">You can insert a tuple.<a href="#You+can+insert+a+tuple." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The index is the position at which the first element of the inserted tuple will go.
</p><pre><code class="prettyprint lang-scala">scala&gt; m.insertM(0, (true, &quot;foo&quot;, 2))
res56: /**/ = (true,foo,2,p,3,t,List(puppies, kittens, goat),Some(is))

scala&gt; m.insertM(2, (true, &quot;foo&quot;, 2))
res57: /**/ = (p,3,true,foo,2,t,List(puppies, kittens, goat),Some(is))

scala&gt; m.insertMRight(0, (true, &quot;foo&quot;, 2))
res58: /**/ = (p,3,t,List(puppies, kittens, goat),Some(is),true,foo,2)

scala&gt; m.insertMRight(1, (true, &quot;foo&quot;, 2))
res59: /**/ = (p,3,t,List(puppies, kittens, goat),true,foo,2,Some(is))
</code></pre><h4 id="You+can+split+at+an+index">You can split at an index<a href="#You+can+split+at+an+index" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; m.splitAt(2)
res61: /**/ = ((p,3),(t,List(puppies, kittens, goat),Some(is)))

scala&gt; m.splitAtRight(4)
res62: /**/ = (p,(3,t,List(puppies, kittens, goat),Some(is)))
</code></pre><h4 id="You+can+zip+two+tuples+together.">You can zip two tuples together.<a href="#You+can+zip+two+tuples+together." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The arity of the resulting tuple is the minimum of the arity of the originals
</p><pre><code class="prettyprint lang-scala">scala&gt; val t1 = (true, 1, Some(&quot;ho gaya&quot;))
t1: /**/ = (true,1,Some(ho gaya))

scala&gt; val t2 = (99, 3.14, None, List(5, 4, 3, 2, 1))
t2: /**/ = (99,3.14,None,List(5, 4, 3, 2, 1))

scala&gt; t1 zip t2
res64: /**/ = ((true,99),(1,3.14),(Some(ho gaya),None))

scala&gt; t2 zip t1
res65: /**/ = ((99,true),(3.14,1),(None,Some(ho gaya)))

scala&gt; t1 zip t2.drop(1)
res66: /**/ = ((true,3.14),(1,None),(Some(ho gaya),List(5, 4, 3, 2, 1)))
</code></pre><h4 id="If+each+element+of+a+tuple+is+a+%2C+you+can+unzip+it">If each element of a tuple is a <code>Tuple2</code>, you can unzip it<a href="#If+each+element+of+a+tuple+is+a+%2C+you+can+unzip+it" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val tz = ((&quot;stannis&quot;, 99), (Some(&quot;the mannis&quot;), 'c'), (List(&quot;husky&quot;, &quot;great dane&quot;), Set(1, 2, 3, 4, 4)))
tz: /**/ = ((stannis,99),(Some(the mannis),c),(List(husky, great dane),Set(1, 2, 3, 4)))

scala&gt; tz.unzip
res67: /**/ = ((stannis,Some(the mannis),List(husky, great dane)),(99,c,Set(1, 2, 3, 4)))
</code></pre><h4 id="You+can+apply+natural+transformations+on+tuples">You can apply natural transformations on tuples<a href="#You+can+apply+natural+transformations+on+tuples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val trt = (List(1, 2, 3), List(true, false), List(&quot;omega&quot;, &quot;alpha&quot;))
trt: /**/ = (List(1, 2, 3),List(true, false),List(omega, alpha))

scala&gt; val sqto: Seq ~&gt; Option = new (Seq ~&gt; Option) {override def apply[T](x: Seq[T]) = x.headOption}
sqto: /**/ = 1@6ded41b4

scala&gt; trt transform sqto
res68: /**/ = (Some(1),Some(true),Some(omega))
</code></pre><h4 id="You+can+down+convert+tuples">You can down convert tuples<a href="#You+can+down+convert+tuples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; import typequux._ // for the Id type constructor
import typequux._

scala&gt; val sqdo: Seq ~&gt; Id = new (Seq ~&gt; Id) {override def apply[T](x: Seq[T]) = x(0)}
sqdo: typequux.~&gt;[Seq,typequux.typequux.Id] = 1@5112b55

scala&gt; trt down sqdo
res69: (Int, Boolean, String) = (1,true,omega)
</code></pre><h4 id="You+can+apply+a+tuple+of+functions+to+a+tuple+of+arguments">You can apply a tuple of functions to a tuple of arguments<a href="#You+can+apply+a+tuple+of+functions+to+a+tuple+of+arguments" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Or you could yoda-apply it.
</p><pre><code class="prettyprint lang-scala">scala&gt; val funcs = ((i: Int) =&gt; i &lt;&lt; 1, (s: String) =&gt; s.toUpperCase, (d: Double) =&gt; d * 2, (l: List[Int]) =&gt; l.headOption)
funcs: (Int =&gt; Int, String =&gt; String, Double =&gt; Double, List[Int] =&gt; Option[Int]) = (&lt;function1&gt;,&lt;function1&gt;,&lt;function1&gt;,&lt;function1&gt;)

scala&gt; val args1 = (1, &quot;alpha&quot;, 4.0, List(1, 2, 3))
args1: /**/ = (1,alpha,4.0,List(1, 2, 3))

scala&gt; val args2 = (2, &quot;OMEGA&quot;, 9.0, List[Int]())
args2: /**/ = (2,OMEGA,9.0,List())

scala&gt; funcs fapply args1
res70: /**/ = (2,ALPHA,8.0,Some(1))

scala&gt; funcs fapply args2
res71: /**/ = (4,OMEGA,18.0,None)

scala&gt; args1 yapply funcs // yoda apply: to this data, apply the function
res72: /**/ = (2,ALPHA,8.0,Some(1))

scala&gt; args2 yapply funcs
res74: /**/ = (4,OMEGA,18.0,None)
</code></pre><h4 id="You+can+perform+arbitrary+arity+zips+and+zipwiths">You can perform arbitrary arity zips and zipwiths<a href="#You+can+perform+arbitrary+arity+zips+and+zipwiths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">scala&gt; val tz1 = (List(1, 2, 3), List(true, false))
tz1: /**/ = (List(1, 2, 3),List(true, false))

scala&gt; val tz2 = (Vector(1, 2, 3), Vector(true, false), Vector(&quot;alpha&quot;, &quot;beta&quot;, &quot;charlie&quot;, &quot;delta&quot;), Vector(3.14, 2.718, 6.262))
tz2: /**/ = (Vector(1, 2, 3),Vector(true, false),Vector(alpha, beta, charlie, delta),Vector(3.14, 2.718, 6.262))

scala&gt; tz1.azipped
res75: List[(Int, Boolean)] = List((1,true), (2,false))

scala&gt; tz2.azipped
res76: scala.collection.immutable.Vector[(Int, Boolean, String, Double)] = Vector((1,true,alpha,3.14), (2,false,beta,2.718))

scala&gt; tz1.zipwith { case (i, b) =&gt; (b, i) }
res77: List[(Boolean, Int)] = List((true,1), (false,2))

scala&gt; tz2.zipwith { case (i, b, s, d) =&gt; ((i, s), (b, d)) }
res78: scala.collection.immutable.Vector[((Int, String), (Boolean, Double))] = Vector(((1,alpha),(true,3.14)), ((2,beta),(false,2.718)))

scala&gt; val fibs: Stream[BigInt] = { def go(i: BigInt, j: BigInt): Stream[BigInt] = (i + j) #:: go(j, i + j); BigInt(0) #:: BigInt(1) #:: go(0, 1)}
fibs: Stream[BigInt] = Stream(0, ?)

scala&gt; val nats: Stream[Int] = Stream.from(1)
nats: Stream[Int] = Stream(1, ?)

scala&gt; val pows: Stream[Long] = { def go(n: Int): Stream[Long] = (1L &lt;&lt; n) #:: go(n + 1); go(1)}
pows: Stream[Long] = Stream(2, ?)

scala&gt; val sz1 = (fibs, nats)
sz1: (Stream[BigInt], Stream[Int]) = (Stream(0, ?),Stream(1, ?))

scala&gt; val sz2 = (fibs, nats, pows)
sz2: /**/ = (Stream(0, ?),Stream(1, ?),Stream(2, ?))

scala&gt; val sz3 = (fibs, nats, Stream.empty[String])
sz3: /**/ = (Stream(0, ?),Stream(1, ?),Stream())

scala&gt; sz1.azipped
res79: Stream[(BigInt, Int)] = Stream((0,1), ?)

scala&gt; sz2.azipped
res80: Stream[(BigInt, Int, Long)] = Stream((0,1,2), ?)

scala&gt; sz3.azipped
res81: Stream[(BigInt, Int, String)] = Stream()

scala&gt; (res79 take 3).toVector
res82: Vector[(BigInt, Int)] = Vector((0,1), (1,2), (1,3))

scala&gt; (res80 take 3).toList
res83: List[(BigInt, Int, Long)] = List((0,1,2), (1,2,4), (1,3,8))

scala&gt; sz1.zipwith { case (b, i) =&gt; (i, b) }
res84: Stream[(Int, BigInt)] = Stream((1,0), ?)

scala&gt; (res84 take 3).toList
res85: List[(Int, BigInt)] = List((1,0), (2,1), (3,1))

scala&gt; sz2.zipwith { case (b, i, l) =&gt; (i, (b, l)) }
res86: Stream[(Int, (BigInt, Long))] = Stream((1,(0,2)), ?)

scala&gt; (res86 take 4).toArray
res87: Array[(Int, (BigInt, Long))] = Array((1,(0,2)), (2,(1,4)), (3,(1,8)), (4,(2,16)))

scala&gt; sz3.zipwith { case (b, i, s) =&gt; (i, b, s) }
res88: Stream[(Int, BigInt, String)] = Stream()
</code></pre><h4 id="Common+View">Common View<a href="#Common+View" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Provided that there exists an implicit conversion to a common type for each element of a tuple, you can <code>foreach</code>, <code>count</code>, <code>exists</code>, <code>forall</code> and <code>foldleft</code> as you would use with a standard library collection. 
</p><pre><code class="prettyprint lang-scala">scala&gt; import language.implicitConversions
import language.implicitConversions

scala&gt; :paste
// Entering paste mode (ctrl-D to finish)

trait Lengthable {
  def length: Int
}
object Lengthable {
  implicit def int2Lengthable(i: Int): Lengthable = new Lengthable {
    override def length = i
  }
  implicit def string2Lengthable(s: String): Lengthable = new Lengthable {
    override def length = s.length
  }
  implicit def seq2Lengthable[T](s: Seq[T]): Lengthable = new Lengthable {
    override def length = s.length
  }
  implicit def bool2Lengthable(b: Boolean): Lengthable = new Lengthable {
    override def length = if (b) 1 else 0
  }
  implicit def tuple2Lengthable[T, U](t: (T, U))(implicit ev0: T =&gt; Lengthable, ev1: U =&gt; Lengthable): Lengthable =
    new Lengthable {
      override def length = t._1.length * t._2.length
    }
}

// Exiting paste mode, now interpreting.

defined trait Lengthable
defined object Lengthable

scala&gt; val cvt = (3, &quot;oogachaka&quot;, List(1, 2, 3), Vector(&quot;cow&quot;, &quot;chicken&quot;), false, (5, &quot;ho gaya&quot;))
cvt: /**/ = (3,oogachaka,List(1, 2, 3),Vector(cow, chicken),false,(5,ho gaya))

scala&gt; var maxl = 0
maxl: Int = 0

scala&gt; cvt.foreach[Lengthable](l =&gt; maxl = math.max(maxl, l.length))

scala&gt; maxl
res90: Int = 35

scala&gt; cvt.exists[Lengthable](_.length &lt; 10)
res91: Boolean = true

scala&gt; cvt.forall[Lengthable](_.length &gt; 0)
res92: Boolean = false

scala&gt; cvt.count[Lengthable](_.length &gt; 5)
res93: Int = 2

scala&gt; cvt.foldLeft[Int, Lengthable](0)(_ + _.length)
res94: Int = 52
</code></pre><h4 id="They+can+be+converted+to+regular+lists">They can be converted to regular lists<a href="#They+can+be+converted+to+regular+lists" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The element type of the list is the least upper bound of the element types of the tuple.
</p><pre><code class="prettyprint lang-scala">scala&gt; val tp1 = (42, 22L, 3.14159, 'c', 2.718f)
tp1: (Int, Long, Double, Char, Float) = (42,22,3.14159,c,2.718)

scala&gt; tp1.toList
res95: List[AnyVal] = List(42, 22, 3.14159, c, 2.718)

scala&gt; val tp2 = (List(1, 2,3), List(true, false))
tp2: (List[Int], List[Boolean]) = (List(1, 2, 3),List(true, false))

scala&gt; tp2.toList
res97: List[List[AnyVal]] = List(List(1, 2, 3), List(true, false))

scala&gt; val tp3 = (Some(&quot;foo&quot;), Some(Set(1,2 , 3)))
tp3: (Some[String], Some[scala.collection.immutable.Set[Int]]) = (Some(foo),Some(Set(1, 2, 3)))

scala&gt; tp3.toList
res98: List[Some[Object]] = List(Some(foo), Some(Set(1, 2, 3)))

scala&gt; val tp4 = (Some(&quot;foo&quot;), Some(Set(1,2 , 3)), None)
tp4: (Some[String], Some[scala.collection.immutable.Set[Int]], None.type) = (Some(foo),Some(Set(1, 2, 3)),None)

scala&gt; tp4.toList
res99: List[Option[Object]] = List(Some(foo), Some(Set(1, 2, 3)), None)
</code></pre><h3 id="See+also">See also<a href="#See+also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://github.com/harshad-deo/typequux/blob/master/src/main/scala/typequux/TupleOps.scala">Source</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Covariant+Heterogenous+Lists.html">HLists</a>
</li><li><a href="https://harshad-deo.github.io/typequux/Understanding+Constraints.html">Constraints</a>
</li></ul><h2 id="Sized+Vectors">Sized Vectors<a href="#Sized+Vectors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.SizedVector">API</a>
</li><li><a href="https://github.com/harshad-deo/typequux/tree/master/src/main/scala/typequux/SizedVector.scala">Source</a></li></ul><h2 id="String+Indexed+Collections">String Indexed Collections<a href="#String+Indexed+Collections" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.StringIndexedCollection">API</a>
</li><li><a href="https://github.com/harshad-deo/typequux/tree/master/src/main/scala/typequux/StringIndexedCollection.scala">Source</a></li></ul><h2 id="Records">Records<a href="#Records" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.Record">API</a>
</li><li><a href="https://github.com/harshad-deo/typequux/blob/master/src/main/scala/typequux/Record.scala">Source</a></li></ul><h2 id="Understanding+Constraints">Understanding Constraints<a href="#Understanding+Constraints" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="See+Also">See Also<a href="#See+Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="https://harshad-deo.github.io/typequux/api/#typequux.constraint.package">API</a></li></ul>
          </div>
        </div>
        <div class="header">
          <div class="container">
        <div class="span-16 prepend-1 append-1">
          <div class="span-16 top nav">
            <div class="span-16 title">
              <span>TypeQuux</span> — Combined Pages
            </div>
          </div>
        </div>
      </div>
        </div>
        <div class="footer">
          
        </div>
        <a href="http://github.com/harshad-deo/typequux" class="fork nav"><img src="img/fork.png" alt="Fork me on GitHub"/></a>
        
      </body>
    </html>